<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2021/10/01/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/10/01/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无论大小厂，Java基础都是面试必问的问题，所以在此记录Java基础知识，用以巩固自己的基础，为未来找到心仪的厂，做好准备。<br>题目来源：JavaGuide</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>答：<br></p><ul><li>面向对象：<strong>易拓展，易维护，易复用，</strong>因为有封装，继承，多态的特性，但一般性能没面向过程高（实例化消耗大量资源）；</li><li>面向过程：<strong>性能比面向对象高，但不容易拓展，维护和复用。</strong></li></ul><h3 id="关于JDK，JRE，JVM"><a href="#关于JDK，JRE，JVM" class="headerlink" title="关于JDK，JRE，JVM"></a>关于JDK，JRE，JVM</h3><p>答：<br></p><ul><li>JVM：运行字节码的虚拟机，不同系统有不同实现，但都能运行同一个字节码，得出相同的结果</li><li>字节码：JVM能够运行，解析的文件，面向JVM</li><li>编译过程： .java -&gt; .class -&gt; 机器码 ,其中，JavaC将.java编译为.class，JVM将.class转换为机器码</li></ul><hr><ul><li>JRE：Java运行时环境，它包含了运行已编译Java程序的所有必备内容，比如JDK,Java类库，命令等，但不能创建，编写新Java程序</li><li>JDK：Java开发者工具包，功能齐全的Java SDK，它除了拥有JRE外，还有编译器JavaC和工具，能够创建和编译程序</li></ul><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>答:<br></p><ul><li>共同点：都是面向对象，都支持封装，继承和多态</li><li>区别：<ol><li>Java不支持指针操作，C++支持，所以Java程序内存更安全</li><li>Java类不支持多继承，C++支持，但Java接口支持多继承</li><li>Java有内存自动管理机制，不用手动释放内存</li><li>Java没有结束符这一概念</li></ol></li></ul><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><p>答:<br></p><ul><li><p>字符常量：</p><ol><li>单引号括住的一个字符</li><li>相当于一个ASCII码整形值，可进行运算</li><li>在Java中占2个字节</li></ol></li><li><p>字符串常量：</p><ol><li>双引号括住的一串字符</li><li>它表示这串字符在内存中的地址</li><li>占多个字节</li></ol></li></ul><h3 id="重载和重写的区别-常问"><a href="#重载和重写的区别-常问" class="headerlink" title="重载和重写的区别(常问)"></a>重载和重写的区别(常问)</h3><p>答：<br></p><ul><li>重载：对于同样一个方法，能够根据参数的不同，作出不同的处理，返回不同的结果</li><li>重写：对于子类继承父类的同一个方法，参数相同，子类作出不同于父类的处理，覆盖父类方法时，就是重写</li></ul><p>其区别在于： </p><ul><li>重载发生在编译期，在同一个类中，重载方法的<strong>方法名必须相同</strong>，参数类型，个数，顺序，返回值和权限修饰符可以不同；</li><li>重写发生在运行期，是子类对父类方法的重新编写，方法名，参数类型，返回值类型必须相同，不能重写private，final，static方法和构造方法，子类的访问权限必须比父类大，异常范围比父类小</li></ul><h3 id="Java面向对象的特性"><a href="#Java面向对象的特性" class="headerlink" title="Java面向对象的特性"></a>Java面向对象的特性</h3><p>答: <br></p><ul><li>封装:将对象的属性私有化，并提供访问方法给外界使用</li><li>继承:在已有类的基础上，进行继承，并建立新的类，子类能够增加新数据和新方法，也能使用除了private外的父类功能。</li><li>多态:程序定义的引用变量所指向的具体类型和通过引用变量调用的方法只有在程序运行时才能确定。实现多态能够通过继承和接口来实现</li></ul><h3 id="String，StringBuffer，StringBuilder的区别"><a href="#String，StringBuffer，StringBuilder的区别" class="headerlink" title="String，StringBuffer，StringBuilder的区别"></a>String，StringBuffer，StringBuilder的区别</h3><p>答:<br></p><ul><li>可变性:String类对象是不可变的(String类用final修饰了保存字符串的字符数组char[])，而Buffer和Builder是可变的</li><li>线程安全性:Builder是非线程安全的(没有同步锁方法)，Stirng是线程安全的(<strong>不可变的</strong>)，Buffer是线程安全的(有同步锁方法)</li><li>性能:Builider&gt;Buffer&gt;String</li></ul><p>使用场景：</p><ul><li>少量数据:String</li><li>单线程大量数据: StringBuilder</li><li>多线程大量数据: StringBuffer</li></ul><h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>答:<br></p><ul><li>自动装箱：自动将基本数据类型包装成它们对应的引用类型</li><li>自动拆箱：将包装类转换为对应的基本数据类型</li></ul><h3 id="能不能在静态方法中调用非静态成员"><a href="#能不能在静态方法中调用非静态成员" class="headerlink" title="能不能在静态方法中调用非静态成员"></a>能不能在静态方法中调用非静态成员</h3><p>答:<br><br>    不能，因为静态方法无需实例化对象，就能调用，此时如果调用非静态方法，访问非静态成员变量，会报错，所以是非法的</p><h3 id="无参构造方法的作用"><a href="#无参构造方法的作用" class="headerlink" title="无参构造方法的作用"></a>无参构造方法的作用</h3><p>答:<br><br>    调用子类构造方法时，会先调用其父类的构造方法，如果没有调用特定声明的父类构造方法，则会默认调用父类的无参构造方法，如果父类没有该无参构造方法，则会在编译期时报错。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><p>答:<br></p><ul><li>接口方法默认为public，且方法不能实现(JDK8前)，抽象类能有非抽象方法</li><li>接口中除了static和final修饰过的变量，不能有其他变量，抽象类则能有其他变量</li><li>一个类能实现多个接口，但只能实现一个抽象类。</li><li>接口能够实现多继承，扩展多个接口</li><li>抽象类是对类的抽象，是类的一种设计模板，接口是对行为的抽象，是一种行为规范</li></ul><p><strong>Tips:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">JDK8后，接口能有自己的默认方法和静态方法，还有私有方法，但实现接口的类不能去调用它<br></code></pre></td></tr></table></figure><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><p>答:<br></p><ol><li>从形式上，成员变量属于类中的一部分，局部变量则属于方法中的参数或者方法中定义的变量；</li><li>从访问修饰上，成员变量能够被public，private，static修饰，但局部变量不行，它们都能给final修饰</li><li>从储存方式上，成员变量属于对象的一部分，也储存在堆中，局部变量如果是基本数据类型，则存储在栈中，如果是引用数据类型，则存储在堆中，或者指向常量池中的地址</li><li>从生存周期上，成员变量随对象的创建而存活，局部变量在方法被调用后消失</li><li>成员变量没初值时，会根据类型而自动赋初值（除了final修饰过的），而局部变量不会被赋予初值</li></ol><h3 id="创建对象使用什么运算符？对象实例和对象引用的区别？"><a href="#创建对象使用什么运算符？对象实例和对象引用的区别？" class="headerlink" title="创建对象使用什么运算符？对象实例和对象引用的区别？"></a>创建对象使用什么运算符？对象实例和对象引用的区别？</h3><p>答:<br></p><ol><li>用new运算符创建对象实例</li><li>对象实例存在堆中，对象引用存在栈中</li><li>一个对象引用最多指向一个对象实例，一个对象实例可以被多个对象引用指向</li></ol><h3 id="一个类的构造方法的作用？如果一个类没有构造方法，程序还能正确运行吗？为什么？"><a href="#一个类的构造方法的作用？如果一个类没有构造方法，程序还能正确运行吗？为什么？" class="headerlink" title="一个类的构造方法的作用？如果一个类没有构造方法，程序还能正确运行吗？为什么？"></a>一个类的构造方法的作用？如果一个类没有构造方法，程序还能正确运行吗？为什么？</h3><p>答:<br></p><ul><li>作用是为类对象的初始化工作；</li><li>可以执行，因为Java会自动为每个类提供一个默认的无参构造方法</li></ul><h3 id="构造方法特性"><a href="#构造方法特性" class="headerlink" title="构造方法特性"></a>构造方法特性</h3><p>答:<br></p><ul><li>名字与类名相同</li><li>无返回值，也不能用void声明</li><li>生成类对象时，自动调用<h3 id="静态方法和实例方法的区别"><a href="#静态方法和实例方法的区别" class="headerlink" title="静态方法和实例方法的区别"></a>静态方法和实例方法的区别</h3>答:<br></li><li>静态方法无需创建对象就能调用，而实例方法需要创建对象才能调用</li><li>静态方法只能访问静态资源，而不能访问实例资源，实例方法则没有这个限制</li></ul><h3 id="对象相等和指向对象引用的相等的区别"><a href="#对象相等和指向对象引用的相等的区别" class="headerlink" title="对象相等和指向对象引用的相等的区别"></a>对象相等和指向对象引用的相等的区别</h3><p>答:<br></p><ul><li>对象相等指内存中存放的内容是否相等</li><li>引用相等指它们指向内存的地址是否相等</li></ul><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h3><p>答:<br></p><ul><li>对于基本数据类型，==判断的是值是否相等，对于引用类型，==判断的是两个对象的地址是否相等</li><li>equals判断两个对象是否相等，如果类没有覆盖equals方法，则等价于==比较对象是否相等，如果覆盖equals方法，一般比较值是否相等</li></ul><h3 id="hashCode和equals-常问"><a href="#hashCode和equals-常问" class="headerlink" title="hashCode和equals(常问)"></a>hashCode和equals(常问)</h3><p>答:<br></p><ul><li>hashCode的作用是确定对象在哈希表中的索引位置</li><li>如果两个对象相等，则它的hashCode一定相等，但两个对象hashCode相等，它们也不一定相等，所以重写equals时，也必须重写hashCode方法</li></ul><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>答:<br></p><ul><li>final修饰的是一个基本数据类型时，则这个数值初始化后不能再更改，如果是引用类型，则初始化后不能再指向另一个对象</li><li>修饰一个类，则这个类不能被继承，其所有成员方法都会被指定为final</li></ul><h3 id="Java序列化时，怎么让某些属性不被序列化"><a href="#Java序列化时，怎么让某些属性不被序列化" class="headerlink" title="Java序列化时，怎么让某些属性不被序列化"></a>Java序列化时，怎么让某些属性不被序列化</h3><p>答:<br><br>    用transient关键字修饰属性，从而可以让特定变量不被序列化</p><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>答:<br></p><ul><li>浅拷贝：对于基本数据类型，进行值传递，对于引用类型数据，则是生成一个新的引用指向同一个被引用数据</li><li>深拷贝：对于基本数据类型，进行值传递，对于引用类型数据，则是创建一个新的对象，并复制其内容</li></ul><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="List、Set、Map的区别？"><a href="#List、Set、Map的区别？" class="headerlink" title="List、Set、Map的区别？"></a>List、Set、Map的区别？</h3><p>答:<br><br>    - List：存储的元素是有序可重复的<br>    - Set：存储的元素是无序不可重复的<br>    - Map：用键值对进行储存，其中Key是无序不可重复的，Value是无序可重复度的，一个key对应一个value</p><h3 id="ArrayList和LinkedList区别？"><a href="#ArrayList和LinkedList区别？" class="headerlink" title="ArrayList和LinkedList区别？"></a>ArrayList和LinkedList区别？</h3><p>答:<br></p><ul><li>线程安全上：它们都是不同步的，所以不保证线程安全</li><li>底层数据结构： ArrayList底层使用的是Object数组，LinkedList则是双向链表</li><li>插入和删除效率：ArrayList插入和删除受元素位置影响，当在指定位置进行删除和插入时，要对其余元素进行移位，此时时间复杂度为O(n-i)；<br>  LinkedList在指定位置进行删除和插入时，时间复杂度也为O(n),因为需要移动到指定位置才能进行操作；</li><li>是否支持快速随机访问：LinkedList不支持，ArrayList支持，因为ArrayList能通过位置序号来快速访问</li><li>空间占用：ArrayList空间占用主要在list数组尾部的预留空间，LinkedList空间占用主要在每一个元素的结构体</li></ul><h3 id="ArrayList-与-Vector-区别呢-为什么要⽤Arraylist取代Vector？"><a href="#ArrayList-与-Vector-区别呢-为什么要⽤Arraylist取代Vector？" class="headerlink" title="ArrayList 与 Vector 区别呢?为什么要⽤Arraylist取代Vector？"></a>ArrayList 与 Vector 区别呢?为什么要⽤Arraylist取代Vector？</h3><p>答:<br><br>区别：Vector<strong>线程安全，ArrayList线程是不安全的</strong>，它们底层都是Object[]存储的，所以用ArrayList取代Vector</p><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><p>答:<br></p><ul><li>线程安全性：HashMap是线程不安全的，HashTable是线程安全的，因为内部方法大都用过Synchronized修饰过，(或者用CurrentHashMap，它也是线程安全的)</li><li>使用效率：HashMap效率比Table要高</li><li>是否支持空键值对：HashTable不支持空键值对，HashMap支持空键值对，但空键只能有一个，空值能够有多个</li><li>容量和扩容：Map的默认容量为11，每次扩容为原来的2n+1，Table默认容量为16，每次扩容为原来的2倍</li><li>底层数据结构：HashMap会在大于链表阈值时，将链表转换为红黑树，减少检索时间，HashTable没有这样的机制</li></ul><h3 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h3><p>答:<br></p><ul><li>HashSet是基于HashMap实现的，其主要区别在于Map实现Map接口，Set实现set接口</li><li>Map储存键值对，Set储存的则是对象</li><li>比较时，Map计算hashcode是否相同，Set除了比较hashcode外还通过equals比较</li></ul><h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>答:<br></p><ul><li>并发下，Rehash会造成元素之间形成一个环形循环列表，甚至会造成数据丢失，所以多线程并发下更推荐使用ConcurrentHashMap</li></ul><h3 id="ConcurrentHashMap和HashTable的区别"><a href="#ConcurrentHashMap和HashTable的区别" class="headerlink" title="ConcurrentHashMap和HashTable的区别"></a>ConcurrentHashMap和HashTable的区别</h3><p>答:<br></p><ul><li>主要区别体现在实现线程安全的方式不同</li><li>底层数据结构:Map是采用分段数组+链表/红黑二叉树实现，Table是采用数组+链表</li><li>实现线程安全：JDK8后，Map采用Node数组+链表+红黑树的数据结构，用synchronized和CAS操作，减少锁的竞争，提高并发量，而Table则是只用synchronized实现线程安全，但线程一旦增多，锁的竞争就会增加，从而效率越来越低</li></ul><h3 id="HashSet-LinkedHashSet和TreeSet三者异同"><a href="#HashSet-LinkedHashSet和TreeSet三者异同" class="headerlink" title="HashSet,LinkedHashSet和TreeSet三者异同"></a>HashSet,LinkedHashSet和TreeSet三者异同</h3><p>答:<br></p><ul><li>HashSet是Set的主要实现类，它底层是用HashMap实现，线程不安全，可以存null值</li><li>LinkedHashSet是HashSet的子类，能够按照添加顺序进行遍历</li><li>Treeset底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序,有序，唯一</li></ul><h3 id="实现Collection接口和Map接口"><a href="#实现Collection接口和Map接口" class="headerlink" title="实现Collection接口和Map接口"></a>实现Collection接口和Map接口</h3><ol><li>List<ul><li>ArrayList</li><li>Vector </li><li>LinkedList</li></ul></li><li>Set<ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li><li>Map<ul><li>HashMap</li><li>LinkedHashMap</li><li>HashTable</li><li>TreeMap</li></ul></li></ol><h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="线程，进程，程序的概念以及它们的关系"><a href="#线程，进程，程序的概念以及它们的关系" class="headerlink" title="线程，进程，程序的概念以及它们的关系"></a>线程，进程，程序的概念以及它们的关系</h3><p>答:<br></p><ul><li>程序是一种含有指令和数据的文件，它存储在数据存储设备中，是静态代码</li><li>进程是程序执行的一次过程，是运行程序的基本单位，是动态的，一个进程表示一个运行中的程序，每个进程之间相互独立，互不干扰</li><li>线程是进程中的执行单位，一个进程可以拥有多个线程，每个线程之间共享同一个进程的资源和内存空间，每个线程之间能被互相干扰，每个线程都有自己的计数器，私有方法栈和虚拟机栈</li></ul><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>答:<br></p><ul><li>并发：同一个<strong>时间段</strong>内，多个任务在执行(它们不一定是同时开始)</li><li>并行: 单位时间内，多个任务同时进行</li></ul><h3 id="为啥用多线程，多线程带来的问题"><a href="#为啥用多线程，多线程带来的问题" class="headerlink" title="为啥用多线程，多线程带来的问题"></a>为啥用多线程，多线程带来的问题</h3><p>答:<br></p><ul><li>从计算机角度，使用多线程能够提高效率，减少线程上下文切换，从IT发展角度，能够提升系统的运行效率和并发性能，创造更多价值</li><li>带来的问题：内存泄漏，上下文切换，死锁，数据丢失等</li></ul><h3 id="Java中线程的状态"><a href="#Java中线程的状态" class="headerlink" title="Java中线程的状态"></a>Java中线程的状态</h3><p>答:<br></p><ul><li>NEW 线程被构建，没调用start方法，处于初始态<ul><li>RUNNABLE 线程处于运行态度</li><li>BLOCKED 阻塞态，线程等待获取锁的状态</li><li>WAITING 等待态，线程等待其他线程作出特定操作</li><li>TIME_WAITING 超时等待态，线程在指定时间内自行返回</li><li>TERMINATED 终止态，线程执行完后的状态</li></ul></li></ul><h3 id="什么是死锁？死锁怎么产生的？怎么避免？怎么解决？"><a href="#什么是死锁？死锁怎么产生的？怎么避免？怎么解决？" class="headerlink" title="什么是死锁？死锁怎么产生的？怎么避免？怎么解决？"></a>什么是死锁？死锁怎么产生的？怎么避免？怎么解决？</h3><p>答:<br></p><ol><li>死锁：多个线程同时被阻塞，它们中的一个或者多个都在等某个资源被释放，由于资源都被占用，所以它们都会无限期地处于阻塞态，从而导致程序不能正常结束。</li><li>产生死锁的四个条件：</li></ol><ul><li>互斥条件：资源某一时刻只由一个线程占有</li><li>请求与保持条件：一个线程因请求资源而阻塞时，不会释放已经占有的资源</li><li>不剥夺条件：线程获得的资源在使用完前不能被其他线程剥夺使用，只有使用完后才释放</li><li>循环等待条件：若干线程之间等待资源形成一种环形等待资源状态</li></ul><ol start="3"><li>避免死锁的方法：</li></ol><ul><li>破坏保持条件：一次性申请所有需要的资源</li><li>破坏不剥夺条件：占有资源的线程请求不到其他资源时，主动释放当前占有资源</li><li>破坏循环等待条件：线程按规定顺序申请资源，按相反顺序释放资源。</li></ul><h3 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h3><p>答:<br></p><ul><li>sleep()没有释放所，wait()释放锁</li><li></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="Exception和Error类异常"><a href="#Exception和Error类异常" class="headerlink" title="Exception和Error类异常"></a>Exception和Error类异常</h3><p>答:<br></p><ul><li>两类都有共同的父类Throwable类</li><li>Exception类是程序可处理异常，可用通过try catch来捕获，Exception又可以分为受检查异常(必须处理)和不受检查异常(可以不处理)</li><li>Error为程序无法处理异常，没办法通过catch捕获，例如虚拟机运行错误，虚拟机内存不足，类定义错误等，遇到错误，一般会终止线程</li><li>常用方法有getMessage(),toString(),printStackTrace()等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习</title>
    <link href="/2021/03/31/RabbitMQ/RabbitMQ/"/>
    <url>/2021/03/31/RabbitMQ/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h1><h2 id="什么是消息中间件-MQ"><a href="#什么是消息中间件-MQ" class="headerlink" title="什么是消息中间件(MQ)"></a>什么是消息中间件(MQ)</h2><p>基于<strong>队列</strong>模型实现同步/异步传输数据</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><p>实现支撑高并发，异步解耦，流量削峰，降低耦合度</p><h2 id="核心概念-名词"><a href="#核心概念-名词" class="headerlink" title="核心概念/名词"></a>核心概念/名词</h2><ol><li>Producer: 生产者，投递消息到MQ服务器端</li><li>Consumer: 消费者，从MQ服务器端获取消息处理业务逻辑</li><li>Broker: MQ服务器端</li><li>Topic: 根据业务逻辑进行消息分类，话题</li><li>Queue: 存放消息模型，队列，数组，链表</li><li>Message: 生产者产生的消息报文，一般是Json格式</li></ol><h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><ol><li>传统Http请求基于<strong>响应与请求</strong>的模型，在高并发的请求下，客户端的大量请求到达服务器端会有可能让服务器端的请求堆积</li><li>Tomcat服务器每个请求都有独立的线程，如果超过最大线程数，就会将请求缓存到队列中，如果请求堆积过多，则会可能导致tomcat服务器崩溃</li><li>处理复杂的业务逻辑时，耗时过长会造成客户端等待，超时就会发生重试策略，从而引发幂等性问题</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>异步发送短信</li><li>异步发送优惠券</li><li>处理耗时的操作</li></ol><h2 id="mq架构常见问题"><a href="#mq架构常见问题" class="headerlink" title="mq架构常见问题"></a>mq架构常见问题</h2><ol><li><p>生产者投递消息给mq服务器，MQ服务器需要缓存该消息</p></li><li><p>如果mq服务器宕机，消息如何保证不丢失<br>答：持久化机制</p></li><li><p>如果mq服务器接收到生产者的消息时，消费者不在，该消息是否消失？<br>答：不会，因为消息确认机制，mq服务器必须要消费者消费该消息后，返回通知给mq服务器，mq服务器才会从队列中删除该消息</p></li><li><p>消息推送和消息拉取的区别<br>答：<br>MQ服务器将消息推送给消费者：消费者已经和mq服务器保持长连接<br>消费者主动拉取消息：消费者第一次启动上线，与mq服务器进行长连接</p></li></ol><ol start="5"><li>MQ如何实现抗高并发，有何缺陷？怎么解决？<br>答：消费者会根据实际能力情况，去拉取MQ服务器端的消息，默认情况下，取出一条消息进行消费；缺陷在于效率过慢，导致延迟问题；解决方法则是实现消费者集群、消费者批量获取消息即可。</li></ol><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="安装与运行"><a href="#安装与运行" class="headerlink" title="安装与运行"></a>安装与运行</h3><ol><li>安装ErLang (ErLang为RabbitMQ的必备环境)</li><li>安装RabbitMQ</li><li>安装控制台插件<br>cd到RabbitMQ安装目录的sbin下，执行一下命令安装插件<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rabbitmq-plugins <span class="hljs-builtin-name">enable</span> rabbitmq_management<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure></li><li>浏览器访问127.0.0.1:15627 出现登录页面即可</li></ol><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ol><li><p>Virtual Hosts <br><br>相当于分类类名，存放同类的队列.每个Virtual Hosts之间相互独立，有自己独立的队列和交换机</p></li><li><p>交换机 <br><br>将消息<strong>分发</strong>到某个类的某个队列进行储存(相当于路由)，与Nginx类似</p></li><li><p>控制管理平台<br><br>默认为127.0.0.1:15672进行访问，账户密码都为guest； 25672为rabbitmq集群通信端口号；amqp 5672为rabbitmq内部通信的一个端口号</p></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>连接RabbitMQ服务端配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.mq.MqConfig;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MqConnection</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br><br>        <span class="hljs-comment">//1.连接哪个VH,注意：RabbitMQ 5.0+版本后，只需写VH名称即可，不用添加/</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;myVirtualHost&quot;</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 2.设置账号密码</span><br><span class="hljs-comment">        * */</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 3.mq连接信息地址</span><br><span class="hljs-comment">        * 此处应连接5672端口</span><br><span class="hljs-comment">        * */</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br><br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最简单的生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.mq.MqRoles;<br><br><span class="hljs-keyword">import</span> com.example.mq.MqConfig.MqConnection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QueueName = <span class="hljs-string">&quot;myQueue&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br><br>        String msg = <span class="hljs-string">&quot;Hello RabbitMQ!&quot;</span>;<br><br>        <span class="hljs-comment">//1.创建连接</span><br>        Connection connection = MqConnection.getConnection();<br><br>        <span class="hljs-comment">//2.创建通道,参数durable:是否持久化，默认false</span><br>        Channel channel = connection.createChannel();<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QueueName,<span class="hljs-keyword">null</span>,msg.getBytes());<br><br>        <span class="hljs-comment">//3.关闭流程</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>最简单的消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.mq.MqRoles;<br><br><span class="hljs-keyword">import</span> com.example.mq.MqConfig.MqConnection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QueueName = <span class="hljs-string">&quot;myQueue&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//1.建立连接</span><br>        Connection connection = MqConnection.getConnection();<br><br>        <span class="hljs-comment">//2.设置通道</span><br>        Channel channel = connection.createChannel();<br>        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                String msg = <span class="hljs-keyword">new</span> String(body,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;Consumer get message: &quot;</span>+msg);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">//3.监听队列</span><br>        <span class="hljs-comment">//autoACK:是否自动签收 true是，false否，一般实际开发是手动签收。</span><br>        channel.basicConsume(QueueName,<span class="hljs-keyword">true</span>,defaultConsumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="MQ如何保证消息不丢失"><a href="#MQ如何保证消息不丢失" class="headerlink" title="MQ如何保证消息不丢失"></a>MQ如何保证消息不丢失</h2><h3 id="从角色来说"><a href="#从角色来说" class="headerlink" title="从角色来说"></a>从角色来说</h3></li><li><p>生产者<br><br>生产者要确保消息投递到服务器端<br>Ack消息确认机制<br>同步或者异步的形式<br>几种方式：<br>①：Confirms<br>②：事务消息 </p></li><li><p>消费者<br><br>消费者只有在成功消费消息后，才能通知服务器端删除该消息(注意:Kafka消费完后，仍然会保留在服务器端一段时间)</p></li></ol><p><strong>如果消费者设置手动签收，那么消费者就不会返回通知给服务器端删除该消息，服务器也不会继续将消息传递给消费者</strong><br>3. 服务器端<br><br>服务器端对队列中的消息进行持久化，持久化到硬盘</p><h2 id="MQ工作队列模型"><a href="#MQ工作队列模型" class="headerlink" title="MQ工作队列模型"></a>MQ工作队列模型</h2><h3 id="均摊消费"><a href="#均摊消费" class="headerlink" title="均摊消费"></a>均摊消费</h3><p>默认的传统队列，存在不公平性，消费能力强的消费者消费信息多，能者多劳</p><h2 id="MQ交换机类型"><a href="#MQ交换机类型" class="headerlink" title="MQ交换机类型"></a>MQ交换机类型</h2><ol><li>Direct Exchange 直连交换机</li><li>Fanout Exchange 扇形交换机</li><li>Topic Exchange 主题交换机</li><li>Headers Exchange 头交换机</li></ol><h2 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>创建的几个队列，对应几个消费者</li><li>队列绑定交换机</li><li>生产者投递消息到交换机中，交换机在将消息分配给两个队列中存放起来；</li><li>消费中从队列中获取消息</li></ol>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerCompose</title>
    <link href="/2021/03/28/DockerCompose/DockerCompose/"/>
    <url>/2021/03/28/DockerCompose/DockerCompose/</url>
    
    <content type="html"><![CDATA[<h1 id="认识DockerCompose"><a href="#认识DockerCompose" class="headerlink" title="认识DockerCompose"></a>认识DockerCompose</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>负责对docker容器集群的快速编排</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ol><li>服务(Service): 一个应用的容器，服务可以存在多个</li><li>项目(Project): 由一组关联的应用容器组成的一个完整的业务单元，在”docker-compose.yml”中定义</li></ol><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>例子：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&quot;x.x&quot;</span> <span class="hljs-meta">#docker版本</span><br><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">tomcat:</span> <span class="hljs-meta">#服务名</span><br><span class="hljs-symbol">image:</span> <span class="hljs-meta">#镜像名或镜像id</span><br><span class="hljs-symbol">container_name:</span> mycat <span class="hljs-meta">#--name=mycat,容器名</span><br><span class="hljs-symbol">ports:</span> <span class="hljs-meta">#宿主机与容器端口号映射</span><br>- <span class="hljs-string">&quot;8080:8080&quot;</span> <span class="hljs-meta">#用字符串形式写端口号，否则会按60进制来处理这个数据，以至出错</span><br><span class="hljs-symbol">volumes:</span> <span class="hljs-comment">//数据卷指定</span><br>- <span class="hljs-meta-keyword">/root/</span>apps:<span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/tomcat/</span>webapps <span class="hljs-meta">#绝对路径映射</span><br>- tomcatwebapps:<span class="hljs-meta-keyword">/usr/</span>local<span class="hljs-meta-keyword">/tomcat/</span>webapps <span class="hljs-meta">#创建卷自动映射，如果使用这种方式，则要声明volumes!</span><br><span class="hljs-symbol">networks:</span> <span class="hljs-meta">#指定服务使用哪个网桥，默认用bridge</span><br>- hello<br>depends_on： <span class="hljs-meta">#表示这个容器依赖于哪些容器，在这些容器启动后才会启动（不是这些服务启动完后才启动！！）</span><br>- mysql<br>- redis<br>- .... <span class="hljs-meta">#服务名</span><br><span class="hljs-symbol">healthcheck:</span> <span class="hljs-meta">#心跳检测</span><br><span class="hljs-symbol">test:</span> [<span class="hljs-string">&quot;cmd&quot;</span>,<span class="hljs-string">&quot;curl&quot;</span>,<span class="hljs-string">&quot;-f&quot;</span>,<span class="hljs-string">&quot;http://localhost&quot;</span>]<br><span class="hljs-symbol">interval:</span> <span class="hljs-number">1</span>m30s<br><span class="hljs-symbol">timeout:</span> <span class="hljs-number">10</span>s<br><span class="hljs-symbol">retries:</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">sysctls:</span> <span class="hljs-meta">#部分容器需要修改系统内部参数，否则会无法启动</span><br>net.core.somaxconn: <span class="hljs-number">1024</span><br>net.ipv4.tcp_syncookies: <span class="hljs-number">0</span><br><br><span class="hljs-symbol">ulimits:</span> <span class="hljs-meta">#修改容器中系统内部进程数限制</span><br><span class="hljs-symbol">nproc:</span> <span class="hljs-number">65535</span><br><span class="hljs-symbol">nofile:</span><br><span class="hljs-symbol">soft:</span> <span class="hljs-number">20000</span><br><span class="hljs-symbol">hard:</span> <span class="hljs-number">40000</span><br><span class="hljs-symbol">demo:</span><br><span class="hljs-symbol">build:</span> <span class="hljs-meta">#启动服务时，将指定dockerfile打包成镜像，再运行该镜像</span><br><span class="hljs-symbol">context:</span> demo <span class="hljs-meta">#指定dockerfile上下文目录所在目录</span><br><span class="hljs-symbol">dockerfile:</span> XXXX <br><br><span class="hljs-symbol">mysql:</span><br>....<br><span class="hljs-symbol">environment:</span><br>- MYSQL_ROOT_PASSWORD = root <span class="hljs-meta">#环境搭配</span><br><span class="hljs-symbol">env_file:</span> <span class="hljs-meta">#将environment中的配置写入配置文件中更为安全，必须是.env文件</span><br>- mysql.env <span class="hljs-meta">#配置文件路径名 </span><br><span class="hljs-symbol">redis:</span><br>....<br><span class="hljs-symbol">command:</span> <span class="hljs-string">&quot;redis-server --appendonly yes&quot;</span> <span class="hljs-meta">#运行后覆盖容器内内容默认命令，开启持久化</span><br><br><br><span class="hljs-symbol">volumes:</span> <span class="hljs-comment">//声明服务中自动创建的卷名</span><br><span class="hljs-symbol">tomcatwebapps:</span> <span class="hljs-meta">#声明自动创建的卷名 compose会自动在该卷名前加入项目名</span><br>external： <span class="hljs-meta">#是否强制使用指定卷名，如果为true，则一定要先在启动前手动创建该卷，否则会报错</span><br>false<br></code></pre></td></tr></table></figure><h2 id="Compose常用命令"><a href="#Compose常用命令" class="headerlink" title="Compose常用命令"></a>Compose常用命令</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker-compose up -f xxx.yml -d <span class="hljs-regexp">//</span>后台运行对应yml的容器服务<br>docker-compose down <span class="hljs-regexp">//</span>关闭所有服务以及自动创建的网桥，不会关闭数据卷<br>docker-compose exec xxx bash<span class="hljs-regexp">//</span>进入某个容器中进行交互，xxx指yml中的服务名<br>docker-compose ps <span class="hljs-regexp">//</span>展示docker compose中正在运行的容器<br>docker-compose restert [服务名]<span class="hljs-regexp">//</span>重启项目中的某个服务，默认重启整个项目<br>docker-compose rm -fv [服务名] <span class="hljs-regexp">//</span>强删某个服务及其数据卷<br>docker-compose start [服务名]<br>docker-compose stop [服务名]<br>docker-compose top [服务名] <span class="hljs-regexp">//</span>查看某个服务正在运行的进程<br>docker-compose pause [服务名] <span class="hljs-regexp">//</span>暂停某个服务<br>docker-compose unpause [服务名] <span class="hljs-regexp">//</span>取消暂停<br>docker-compose logs [服务名] <span class="hljs-regexp">//</span>查看服务日志<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>粗糙的学完了，咕了好久，懒癌晚期了，麻了</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习</title>
    <link href="/2021/03/15/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/03/15/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h1><p><strong>在使用命令时，要先开启Docker服务！否则不生效</strong></p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span><br>docker version<br></code></pre></td></tr></table></figure><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--help</span><br>docker<br></code></pre></td></tr></table></figure><h2 id="查看本地仓库所有镜-images"><a href="#查看本地仓库所有镜-images" class="headerlink" title="查看本地仓库所有镜(images)"></a>查看本地仓库所有镜(images)</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">docker images <span class="hljs-comment">(+镜像名)</span><br></code></pre></td></tr></table></figure><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">docker pull 镜像名:<span class="hljs-keyword">version</span> <span class="hljs-comment">//配合docker hub下载需要的镜像,默认下载最新版本</span><br>docker pull 镜像名:<span class="hljs-keyword">@DIGEST</span>（摘要）<br></code></pre></td></tr></table></figure><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">docker <span class="hljs-built_in">search</span> 镜像名<br></code></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">image</span> rm 镜像名:version<br>docker <span class="hljs-keyword">image</span> rm 镜像名:镜像id<br>docker <span class="hljs-keyword">image</span> rm -f <span class="hljs-comment">//强行删除</span><br>docker rmi (-f) <span class="hljs-comment">//简写删除</span><br>docker rmi -f $(docker images -q) <span class="hljs-comment">//全部删除</span><br></code></pre></td></tr></table></figure><h2 id="镜像帮助命令"><a href="#镜像帮助命令" class="headerlink" title="镜像帮助命令"></a>镜像帮助命令</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">image</span> --<span class="hljs-keyword">help</span><br></code></pre></td></tr></table></figure><h1 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h1><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> 镜像名：tag||：镜像id</span><br>docker <span class="hljs-keyword">run</span><span class="bash"> -p port1(宿主机端口):port2(容器内服务监听的端口) 镜像名 //-p用于将宿主机端口与容器端口进行映射</span><br>docker <span class="hljs-keyword">run</span><span class="bash"> -d 镜像名//-d 后台启动容器，不输出日志，返回容器id </span><br>docker <span class="hljs-keyword">run</span><span class="bash"> --name 镜像名 //为启动容器起一个唯一的识别名(系统默认生成)</span><br></code></pre></td></tr></table></figure><p><strong>docker本身使用了虚拟化机制，其内部的容器运行在一个沙盒中，是与宿主机隔离的！所以访问沙盒中某个端口时，需要进行映射</strong><br><strong>容器与容器之间是隔离的！且是系统级别的隔离，所以运行在同一个端口也是可行的！但不能映射同一个宿主机端口！！！</strong></p><h2 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker ps<br>docker ps -a <span class="hljs-regexp">//</span>查看所有运行以及未运行的容器<br>docker ps -q <span class="hljs-regexp">//</span>查看正在运行的容器id<br>docker ps -qa <span class="hljs-regexp">//</span>前两条命令的结合<br></code></pre></td></tr></table></figure><h2 id="停止-重启"><a href="#停止-重启" class="headerlink" title="停止,重启"></a>停止,重启</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker start 容器名<span class="hljs-string">||容器ID</span><br>docker restart 容器名<span class="hljs-string">||容器ID</span><br>docker stop 容器名<span class="hljs-string">||容器ID</span><br>docker kill 容器名<span class="hljs-string">||容器ID //与stop的区别是，该命令马上关闭该容器，stop是正常关闭</span><br></code></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> 容器名||容器id //只能删除没运行的容器<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 容器名||容器id //删除正在运行的容器<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-qa</span>) //删除所有容器<br></code></pre></td></tr></table></figure><h2 id="查看容器内服务日志"><a href="#查看容器内服务日志" class="headerlink" title="查看容器内服务日志"></a>查看容器内服务日志</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">docker logs 容器名||容器<span class="hljs-symbol">id</span><br>docker logs -f 容器名||容器<span class="hljs-symbol">id</span> <span class="hljs-comment">//实时展示容器服务日志</span><br>docker logs -t 容器名||容器<span class="hljs-symbol">id</span> <span class="hljs-comment">//加入时间戳</span><br>docker logs --tail number 容器名||容器<span class="hljs-symbol">id</span> <span class="hljs-comment">//显示最后number行日志</span><br></code></pre></td></tr></table></figure><h2 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">docker <span class="hljs-built_in">top</span> 容器名|<span class="hljs-type">|容器id</span><br></code></pre></td></tr></table></figure><h2 id="与容器进行交互"><a href="#与容器进行交互" class="headerlink" title="与容器进行交互"></a>与容器进行交互</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it 容器名||容器id bash <span class="hljs-regexp">//</span>以bash交互方式进行交互，不能缺少！<br><span class="hljs-keyword">exit</span> <span class="hljs-regexp">//</span>退出交互<br></code></pre></td></tr></table></figure><h2 id="容器复制文件到操作系统"><a href="#容器复制文件到操作系统" class="headerlink" title="容器复制文件到操作系统"></a>容器复制文件到操作系统</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qml">docker cp 容器<span class="hljs-attribute">id:</span><span class="hljs-string">容器内的资源路径 操作系统中的路径</span><br><span class="hljs-string">docker</span> cp 宿主机的资源 容器<span class="hljs-attribute">id:</span><span class="hljs-string">容器路径</span><br></code></pre></td></tr></table></figure><h2 id="查看容器的具体信息"><a href="#查看容器的具体信息" class="headerlink" title="查看容器的具体信息"></a>查看容器的具体信息</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker inspect 容器<span class="hljs-built_in">id</span>||容器<span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><h2 id="数据卷-Volume"><a href="#数据卷-Volume" class="headerlink" title="数据卷 Volume"></a>数据卷 Volume</h2><p><strong>作用与特点：</strong><br></p><ol><li>实现宿主机与容器之间的文件共享</li><li>持久化数据(Redis,MySQL等)</li><li>实现容器之间数据的共享和重用</li><li>对数据卷的修改会立即生效影响相应的容器</li><li>对数据卷的更新不会影响镜像</li><li>数据卷默认一直存在，即使容器被删除 </li></ol><p>**使用:**启动容器时启用！启动后不能启用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -v 宿主机目录:容器内目录 //1.</span><br>docker <span class="hljs-keyword">run</span><span class="bash"> -v 卷名:容器内目录 //2.</span><br>docker <span class="hljs-keyword">volume</span><span class="bash"> ls //查看所有数据卷</span><br>docker <span class="hljs-keyword">volume</span><span class="bash"> inspect 数据卷 //查看某个数据卷细节</span><br>docker <span class="hljs-keyword">volume</span><span class="bash"> prune //删除全部没使用的数据卷</span><br>docker <span class="hljs-keyword">volume</span><span class="bash"> rm 数据卷 </span><br></code></pre></td></tr></table></figure><ol><li>自定义数据卷目录 （该方法会自动清空容器目录中的内容）</li><li>自动创建数据卷目录 (该方法如果宿主机目录不存在，会自动创建该目录，并创建映射，然后再把这个容器映射的目录中的内容，复制到宿主机目录中)</li></ol><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker commit -m <span class="hljs-string">&quot;描述&quot;</span> -a <span class="hljs-string">&quot;作者&quot;</span> 容器id<span class="hljs-string">||容器名称 打包的名称:镜像标签</span><br></code></pre></td></tr></table></figure><h2 id="备份镜像"><a href="#备份镜像" class="headerlink" title="备份镜像"></a>备份镜像</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">docker <span class="hljs-keyword">save</span> 镜像名称:标签 -o 文件名<br></code></pre></td></tr></table></figure><h2 id="载入容器"><a href="#载入容器" class="headerlink" title="载入容器"></a>载入容器</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">docker <span class="hljs-keyword">load</span> -i 容器名<br></code></pre></td></tr></table></figure><h1 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h1><p>关键词：<strong>复用，组合</strong><br><br>由于要实现系统级别的隔离，所以每一个镜像都包含了操作系统文件库、镜像依赖库、和镜像本体库这三大类，这也是镜像比较大的原因。<br>复用，组合指的是镜像间可能存在能复用的库，为了实现压缩镜像大小，用分层的方法把这些库组合在一起，从而达到复用的效果。</p><h1 id="Docker网络高级配置"><a href="#Docker网络高级配置" class="headerlink" title="Docker网络高级配置"></a>Docker网络高级配置</h1><p>Docker允许通过外部访问容器或者容器互联的方式来提供网络服务</p><h2 id="Docker容器与操作系统的通信机制"><a href="#Docker容器与操作系统的通信机制" class="headerlink" title="Docker容器与操作系统的通信机制"></a>Docker容器与操作系统的通信机制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Docker启动时，自动在宿主机上创建一个虚拟网桥(bridge)，用于通信，且这个网桥会被分配一个IP地址（网关），此后，运行的镜像挂载在这网桥上时，也会被分配到同一网段上<br><br><br>当容器被创建时，同时会创建一对veth pair接口，这对接口一端在容器，一端挂载在网桥上，此时就实现了主机跟容器，容器与容器之间的通信</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用docker网桥进行容器间的通信时，应该从应用的角度使用！<strong>（不同应用使用不同的网桥！）</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker network ls <span class="hljs-regexp">//</span>查看网桥配置<br>docker network -d bridge 网桥名称 <br>docker run .... --network 网桥名称 <span class="hljs-regexp">//</span>指定网桥运行,网桥不存在时，不会自动创建网桥<br>docker inspect 网桥<span class="hljs-regexp">//</span>查看网桥配置<br></code></pre></td></tr></table></figure><p>**Tips:**容器启动指定了网桥后，与这个网桥关联的容器都能使用容器名与其他容器通信（docker进行了自动映射）（默认网关不能用名字映射访问！）</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>镜像构建文件，描述文件，自定义构建一个镜像</p><h3 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h3><p>用户能够打包自己的应用成镜像，让应用以容器运行</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式</title>
    <link href="/2021/03/01/Redis%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2021/03/01/Redis%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习分布式缓存之前，还应了解<strong>什么是分布式缓存</strong></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>本地缓存</strong>:储存在应用服务器中的数据(My batis)<br><strong>分布式缓存</strong>:储存在应用服务器外的数据(Redis)<br><strong>集群</strong>:<strong>同一种服务</strong>的多个节点在一起对系统提供服务的过程<br><strong>分布式</strong>:<strong>多个不同服务的集群</strong>共同对系统提供服务的系统称为分布式系统<br>(分布式是建立在集群的基础上的)</p><h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><h2 id="分布式缓存的优点"><a href="#分布式缓存的优点" class="headerlink" title="分布式缓存的优点"></a>分布式缓存的优点</h2><p>服务器宕机或电源断电时，也能够保证数据不会丢失（这也是本地缓存最大的问题）。做到分布式系统的数据共享。</p><h2 id="分布式缓存的实现"><a href="#分布式缓存的实现" class="headerlink" title="分布式缓存的实现"></a>分布式缓存的实现</h2><p>Mybatis二级缓存+Redis实现分布式缓存</p><blockquote><ul><li>在mapper中用<cache/>标签开启二级缓存</li><li>自定义一个cache类替换默认的cache实现类</li><li><cache-ref/>适用于多表查询,实现多表缓存共享(关联关系缓存处理)</li></ul></blockquote><h2 id="缓存的优化策略"><a href="#缓存的优化策略" class="headerlink" title="缓存的优化策略"></a>缓存的优化策略</h2><ul><li>对放入Redis的key优化，key的长度不能过长   **策略:**MD5摘要算法进行处理<blockquote><ul><li>MD5算法特点: </li></ul></blockquote><ol><li>一切文件字符串经过MD5处理后，都会生成32位16进制字符串</li><li>不同内容文件经过md5进行加密，加密结果大概率不一致。 （面试经典问题）</li><li>相同内容经过加密，其加密结果一定一致</li></ol></li></ul><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>缓存穿透</li><li>缓存雪崩</li><li>缓存击穿</li><li>解决方法</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>用户<strong>不断</strong>发送请求查询一个缓存和数据库中都<strong>不存在的数据</strong>，导致缓存无法利用的情况叫缓存穿透。此时请求会直接访问数据库，如果请求数量十分巨大，则会导致数据库访问压力大，容易出现宕机挂掉，访问慢等问题。</p><p>解决方法: 用mybatis的cache去解决，将在数据库中没有查询到的结果也进行缓存(key-null),就算下次再进行这个key的查询,也能从cache返回null。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>某一个</strong>热点key在某个时间点过期的时候，被大量用户的并发请求进行访问，由于缓存中这个key过期不存在，从而请求会转向去DB加载数据，并进行新的缓存，此时，大量的并发请求可能会让DB压垮宕机。</p><p>解决方法:</p><ol><li>将热点key设为永不失效</li><li>在key即将过期时，通过异步线程重新设置热点key的生存时间</li><li>缓存获取为null时，对从数据库重新加载数据的过程进行上锁，防止请求压垮数据库(分布式锁)</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>某个时刻</strong>系统中的全部缓存失效，且客户端传来大量的请求，导致缓存无法利用，大量请求转向DB，导致DB阻塞，挂机，宕机的情况称为缓存雪崩</p><blockquote><p>当业务非常庞大时，不同模块的业务数据不同，在放入缓存时，都会设置一个生存时间<br>解决方法:</p></blockquote><ol><li>缓存永久储存 (业务大不推荐,占用内存)</li><li>不同的业务数据设置不同的生存时间（避免同时失效）</li></ol><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>用于解决数据的<strong>冗余备份</strong>,从节点则只用来同步数据.(没有自动故障转移!)<br><strong>主从架构中，从节点只同步读取数据！不进行写数据</strong></p><blockquote><p>从节点能写数据，但没有意义</p></blockquote><p>不常用，因为主节点宕机了，从节点不能顶替主节点，从而redis引入了哨兵机制</p><h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p>哨兵机制是Redis高可用性的解决方案<br><br>它能够监听所有主服务器及其从服务器，当监视的某个主服务器下线了，宕机了，处于不可用状态时，它能够自动将其这个主服务器下的从服务器升级为主服务器。其余从服务器则会变成新主服务器的从服务器。当原来的主服务器重新上线时，则会变成新主服务器的从服务器<br><strong>哨兵机制就是带有自动故障转移功能的主从架构</strong></p><h2 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>数据库名字 IP PORT 哨兵数量<br></code></pre></td></tr></table></figure><blockquote></blockquote><ul><li>只有一定数量的哨兵检测到主服务器确实宕机了，才会进行主从交换</li><li>多个数量的哨兵会根据选举机制，选出新的主服务器(防止脑裂问题)</li></ul><h2 id="哨兵运行-Windows环境"><a href="#哨兵运行-Windows环境" class="headerlink" title="哨兵运行(Windows环境)"></a>哨兵运行(Windows环境)</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> 主服务器下的sentinel.conf <span class="hljs-comment">--sentinel</span><br></code></pre></td></tr></table></figure><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul><li>不能处理单节点的并发压力问题(单节点处理高并发请求)</li><li>不能处理单节点的物理内存上限问题(单节点记录巨量的操作记录在AOF日志中,AOF会不断增大，直到占满磁盘)</li></ul><h2 id="解决局限性的方法"><a href="#解决局限性的方法" class="headerlink" title="解决局限性的方法"></a>解决局限性的方法</h2><p><strong>Redis集群</strong></p><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><blockquote><p>springboot操作哨兵时，要开启哨兵的远程连接模式</p></blockquote><h2 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h2><p><img src="/img/redis-learning/%E9%9B%86%E7%BE%A4/1.PNG" alt="集群"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol><li>Redis节点互相连接(Ping-Pong(心跳)机制)，内部用二进制协议优化传输速度和带宽</li><li>集群中超过一半数量以上的节点认为某个节点宕机时，才会确认这个节点宕机(节点建议奇数个，偶数可能会发生歧义)</li><li>客户端能与Redis节点直连，无需代理层，客户端只需连接Redis集群中的任意一个可用节点即可</li><li>对外服务的master节点叫物理节点</li><li>Redis集群把所有的物理节点映射到[0-16383]slot哈希槽(crc16算法)上(slot会被物理节点平均分配，且物理节点数量最大不超过16384)</li></ol><p><strong>CRC16算法</strong></p><ol><li>对集群模式下的所有key进行CRC16计算，计算结果在0-16383之间</li><li>对同一个key进行多次CRC16计算，结果始终一致</li><li>不同的key计算CRC16的结果可能一致</li><li>是能让数据储存在Redis集群中任意一节点的重要原因</li></ol><h2 id="集群创建-Windows环境"><a href="#集群创建-Windows环境" class="headerlink" title="集群创建(Windows环境)"></a>集群创建(Windows环境)</h2><h3 id="配置文件部分"><a href="#配置文件部分" class="headerlink" title="配置文件部分"></a>配置文件部分</h3><ol><li>创建一个主文件夹redis-cluster,用于存放集群的节点</li><li>以每个节点的端口号为名，创建文件夹，并放入redis配置文件</li><li>开始配置，将端口号设置好（比如设置6个节点，则port改为6379-6384），将生成的快照和aof文件名改为”dump-xxxx”,”aof-xxxx”的格式，便于区分</li><li>将bind设置为统一IP（127.0.0.1或者0.0.0.0），保证能够互相连接</li><li>分别修改dir工作目录为当前配置文件目录下(防止出现开启redis服务报can’t not chdir的错误)</li><li>打开aof日志文件功能</li><li>开启cluster集群模式**# cluster-enabled yes**(去掉注释#即可) </li><li>集群配置文件同样以”cluster-config-file nodes-xxxx.conf”格式生成(端口号区分)</li><li>节点超时时间统一设置为5000ms(可选)</li></ol><h3 id="开启集群"><a href="#开启集群" class="headerlink" title="开启集群"></a>开启集群</h3><ul><li>先把配置好的6个节点开启</li></ul><p><strong>注意：网上的方法大都是用ruby脚本来搭建集群，但在Redis for windows 5.0 这版本里，不再使用ruby脚本搭建！而是直接用redis-cli来搭建！</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">redis-cli --cluster create  <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6379 127.0</span>.<span class="hljs-number">0.1:6380</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6381 127.0</span>.<span class="hljs-number">0.1:6382</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6383 127.0</span>.<span class="hljs-number">0.1:6384</span> --cluster-replicas <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>create选项后跟着的是已经开启的节点的IP:PORT号</strong><br>–cluster-replicas选项后面跟着的是每个节点所拥有的从节点数<br><br>这里配置的值是1，则6个节点里有3个主节点，3个从节点<br><br>所以在开启时，自动将输入的前3个节点(按先后顺序)配置为主节点，后面三个配置为从节点(按主节点的先后顺序)<br></p><p>输入命令后，按提示输入yes，等待集群创建好即可</p><h3 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-cli -c -p 主节点端口号 <span class="hljs-regexp">//</span>-c表示进入集群模式，不开启则不会出现节点的跳转！集群也不能使用！<br></code></pre></td></tr></table></figure><p><strong>即使连接了从节点，进行数据的读写时，也会发生节点的跳转</strong><br><br><br>其余关于主节点和从节点的增删改,cmd中输入</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis-<span class="hljs-keyword">cli</span> --<span class="hljs-keyword">cluster</span> <span class="hljs-keyword">help</span> <br></code></pre></td></tr></table></figure><p>查看文档及其相关操作即可</p><h3 id="集群使用注意"><a href="#集群使用注意" class="headerlink" title="集群使用注意"></a>集群使用注意</h3><ol><li>只有主节点才有HashSlot，从节点没有，从节点只负责数据的同步</li><li>主节点不可直接删除(主节点一删除，HashSlot不完整，集群也就不可使用)，从节点能直接删除</li><li>增加新的主节点时，要分配Slot才能用，删除时要先移除拥有的slot才能删除</li><li>修改从节点的所属主节点要连接这个从节点才能修改</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于Redis的基础部分学习都学完了，👴终于学废了，不说了，继续学</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化</title>
    <link href="/2021/02/14/redis%E6%8C%81%E4%B9%85%E5%8C%96/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2021/02/14/redis%E6%8C%81%E4%B9%85%E5%8C%96/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将数据从内存储存到硬盘的过程叫做数据的持久化，这次👴将要学习两种Redis将数据持久化的方法</p><h2 id="快照-Snapshot"><a href="#快照-Snapshot" class="headerlink" title="快照(Snapshot)"></a>快照(Snapshot)</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>将某一时刻的所有数据写入硬盘中</strong>，是redis默认开启的持久化方式，以.rdb的文件保存，也叫RDB方法</p><blockquote><p>Windows环境下dump.rdb保存在安装目录中</p></blockquote><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><ol><li>客户端用bgsave和save的方法来生成快照</li></ol><p><strong>bgsave和save的区别</strong><br></p><ul><li>客户端接受到bgsave指令时，会fork一个子进程负责生成快照，父进程则继续处理执行命令，最大的好处就是不会阻塞服务端，并保证快照的生成</li><li>客户端接受到save指令时，redis的服务器在快照生成完之前，不会相应其他的命令.处于阻塞状态.（主进程负责快照生成）</li></ul><ol start="2"><li>服务器配置自动触发</li></ol><p><strong>在redis.windows.config中进行配置</strong>，如果满足save中的任意一个条件，都会进行快照的生成<br><img src="/img/redis-learning/%E6%8C%81%E4%B9%85%E5%8C%96/1.PNG"><br>3. 服务端接受shutdown指令<br><strong>当服务端接受到shutdown指令时，会执行save指令，阻塞所有客户端，不再执行任何命令。在save执行完后，再关闭服务器</strong></p><h3 id="存在缺陷"><a href="#存在缺陷" class="headerlink" title="存在缺陷"></a>存在缺陷</h3><p><strong>完成一次快照的生成后，到下一次快照的生成之前，这段时间的数据是没有保障的！也就是说，这段时间的数据容易丢失！</strong></p><h2 id="追加日志文件-AOF"><a href="#追加日志文件-AOF" class="headerlink" title="追加日志文件(AOF)"></a>追加日志文件(AOF)</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>将所有客户端执行的命令记录到日志文件中，AOF持久化被执行的命令写入到AOF日志文件的末尾，以此来记录数据发生的变化。只要Redis完整执行一遍aof文件包含的命令，就能恢复aof文件记录的数据集</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><strong>Redis默认没有开启AOF日志文件</strong>，所以要去redis.windows.conf中开启，搜索append only file,将no改为yes,保存并重启redis后就能使用AOF功能。<br><strong>保存的日志文件默认为appendonlyfile.aof</strong></p><h3 id="追加频率"><a href="#追加频率" class="headerlink" title="追加频率"></a>追加频率</h3><ol><li>always (慎用)</li></ol><p><strong>只要有写命令提交，马上就同步到磁盘中， 这种方法虽然能够保证数据的完整与安全，但这种同步策略会导致要对磁盘进行巨量的写入操作，从而导致redis处理命令的速度受限于磁盘的性能</strong><br>更为重要的是,这种模式对于SSD硬盘来讲，会大大降低其寿命（写入放大问题：<strong>不断</strong>向磁盘中写入少量数据(即小文件)会损耗磁盘）</p><ol start="2"><li>everysec(推荐)</li></ol><p><strong>每秒执行一次同步，显式的将多个写命令同步到磁盘中</strong><br><br>该同步策略能够兼顾数据安全和性能，redis每秒同步一次aof文件的性能和不使用任何持久化特性的性能比，没有任何差距，即使系统崩溃，redis也最多丢失一秒内的数据。</p><ol start="3"><li>no(不推荐)</li></ol><p><strong>该策略由系统决定何时进行同步</strong><br><br>对性能没有任何影响，但系统一旦崩溃，会丢失一定数量的数据(大意是如果系统决定同步前，系统宕机了，那么同步前的数据就会全部GG)，而且如果硬盘处理写入速度不够快，当缓冲区被等待被写入的数据填满时，redis会进入阻塞态，从而导致redis处理命令的速度变慢(大意是当系统决定开始同步后，如果数据累积到一定程度，大量的数据写入硬盘时，就又会让redis受限于硬盘的性能)。</p><h3 id="修改频率"><a href="#修改频率" class="headerlink" title="修改频率"></a>修改频率</h3><p><strong>Redis默认同步策略为everysec</strong><br><br>一般来说不用修改，但如果有需求，要去配置文件中，查找appendsync，修改对应频率即可.</p><h3 id="存在缺陷-1"><a href="#存在缺陷-1" class="headerlink" title="存在缺陷"></a>存在缺陷</h3><p>虽然能够保证数据的完整性，但不断的同步也会让持久化文件变得越来越大，数据也会变得冗余，例如，<strong>我们调用100次incr test命令，根据AOF持久化机制，这100条命令会被写入AOF日志中</strong>，实际上，有99条命令是多余的，因为要恢复数据库的状态，只需日志中保存一条set test 100足矣。因此为了<strong>压缩AOF文件</strong>，Redis提供了AOF重写机制。</p><h2 id="AOF日志文件重写"><a href="#AOF日志文件重写" class="headerlink" title="AOF日志文件重写"></a>AOF日志文件重写</h2><p><strong>用于解决AOF日志文件过大的问题</strong></p><h3 id="触发重写的方法"><a href="#触发重写的方法" class="headerlink" title="触发重写的方法"></a>触发重写的方法</h3><ol><li>客户端触发重写<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">BGREWRITEAOF <span class="hljs-regexp">//</span>不会阻塞客户端<br></code></pre></td></tr></table></figure></li><li>服务器配置自动触发<br><br>在配置文件中搜索auto-aof-rewrite-percentage后，即可配置，当启用了aof重写机制时，如果aof文件超过min-size(默认64mb),且比上次的aof文件重写后，大了percentage倍后(默认100%)，就会触发自动重写，如果重写很频繁，可以将percentage改大<br>(AOF文件越小，重写也越频繁，当AOF文件非常大时，重写会消耗大量系统资源，所以要将percentage改大,避免频繁重写)</li></ol><h3 id="重写的原理"><a href="#重写的原理" class="headerlink" title="重写的原理"></a>重写的原理</h3><p><strong>重写并没有读取旧AOF文件</strong>而是将整个内存中的数据库内容以命令的方式，重写了一个新的AOF文件，并替换原AOF文件（与快照有点类似）<br><br></p><blockquote><p>说白了就是文件的替换</p></blockquote><h4 id="重写的大致流程"><a href="#重写的大致流程" class="headerlink" title="重写的大致流程"></a>重写的大致流程</h4><ul><li>redis先fork一个子进程,子进程会根据当前内存中的数据快照，往临时文件中写入重建数据库状态的命令</li><li>父进程继续处理后续的命令，一方面继续把命令追加写入旧的AOF文件中，另一方面则把收到的新命令缓存起来。(目的是为了保证如果子进程重写失败，不会出现数据丢失等问题)</li><li>子进程完成写入后，发信号通知父进程，父进程则会开始把缓存的新命令写入这个临时文件中</li><li>父进程完成写入后，可以用这个临时文件替换掉旧的AOF文件，后续的命令也会在这个新的AOF文件中进行追加</li></ul><h2 id="持久化总结"><a href="#持久化总结" class="headerlink" title="持久化总结"></a>持久化总结</h2><p>两种持久化方法能同时使用，也能单独使用，甚至不使用，具体使用取决于数据和应用决定<br><strong>无论用哪种，将数据持久化到硬盘中是十分有必要的</strong></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好家伙，学到这👴用了快四天的时间，👴果然是个垃圾,这就继续学，不BB了</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五种值类型的操作</title>
    <link href="/2021/02/12/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/02/12/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在对redis有个基本的了解以后，相关的键值操作也是少不了的，上篇文章就学习了相关的key操作，而这次👴就开始学习与value有关的操作</p><h1 id="String类型的操作"><a href="#String类型的操作" class="headerlink" title="String类型的操作"></a>String类型的操作</h1><h2 id="String的内存储存"><a href="#String的内存储存" class="headerlink" title="String的内存储存"></a>String的内存储存</h2><p><img src="/img/redis-learning/String/redis0.PNG" alt="储存模型"><br>key,value都是String类</p><h2 id="设置key-value"><a href="#设置key-value" class="headerlink" title="设置key-value"></a>设置key-value</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> key <span class="hljs-comment">value</span> <br></code></pre></td></tr></table></figure><h2 id="获取key-value"><a href="#获取key-value" class="headerlink" title="获取key-value"></a>获取key-value</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="设置-获取多个key-value"><a href="#设置-获取多个key-value" class="headerlink" title="设置/获取多个key-value"></a>设置/获取多个key-value</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">mset</span></span> key value key value key value...<br><span class="hljs-function"><span class="hljs-title">mget</span></span> key1 key2 key3...<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis14.PNG" alt="mget&amp;mset"></p><hr><h2 id="获取并设置新值"><a href="#获取并设置新值" class="headerlink" title="获取并设置新值"></a>获取并设置新值</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">getset key value</span><br></code></pre></td></tr></table></figure><blockquote><p>设置成功会返回原值(如果新值跟旧值相同，也会操作成功)<br><img src="/img/redis-learning/String/redis15.PNG" alt="getset"></p></blockquote><hr><h2 id="获取对应key的value长度"><a href="#获取对应key的value长度" class="headerlink" title="获取对应key的value长度"></a>获取对应key的value长度</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">strlen</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis16.PNG" alt="strlen"></p><hr><h2 id="追加对应key的value内容"><a href="#追加对应key的value内容" class="headerlink" title="追加对应key的value内容"></a>追加对应key的value内容</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">append</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis17.PNG" alt="append"><br><strong>返回的是追加内容后value的长度</strong></p><hr><h2 id="截取value内容"><a href="#截取value内容" class="headerlink" title="截取value内容"></a>截取value内容</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">getrange<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> //<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>表示索引,从<span class="hljs-number">0</span>开始<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis18.PNG" alt="getrange"></p><hr><h2 id="设置key-value并指定存活时间"><a href="#设置key-value并指定存活时间" class="headerlink" title="设置key-value并指定存活时间"></a>设置key-value并指定存活时间</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">setex key seconds value <span class="hljs-regexp">//</span>秒<br>psetex key milliseconds value <span class="hljs-regexp">//</span>毫秒<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis19.PNG" alt="setex&amp;psetex"></p><hr><h2 id="Setnx"><a href="#Setnx" class="headerlink" title="Setnx"></a>Setnx</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">setnx key value</span><br></code></pre></td></tr></table></figure><blockquote><p>如果key存在，返回0，并不做任何操作（不覆盖），如果不存在，返回1，设置key-value</p></blockquote><p><img src="/img/redis-learning/String/redis20.PNG" alt="setnx"></p><hr><h2 id="原子操作msetnx"><a href="#原子操作msetnx" class="headerlink" title="原子操作msetnx"></a>原子操作msetnx</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">msetnx <span class="hljs-built_in">key</span> value <span class="hljs-built_in">key</span> value <span class="hljs-built_in">key</span> value....<br></code></pre></td></tr></table></figure><p><strong>只要有一个key存在，则不做任何添加操作！</strong><br><img src="/img/redis-learning/String/redis21.PNG" alt="msetnx"></p><hr><h2 id="减操作"><a href="#减操作" class="headerlink" title="减操作"></a>减操作</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">decr <span class="hljs-built_in">key</span><br>decrby <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><strong>只有key对应的value是整型时，操作才会成功！否则会报错</strong><br><img src="/img/redis-learning/String/redis22.PNG" alt="decr"></p><hr><p><img src="/img/redis-learning/String/redis23.PNG" alt="decrby"></p><hr><h2 id="加操作"><a href="#加操作" class="headerlink" title="加操作"></a>加操作</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">incr <span class="hljs-built_in">key</span><br>incrby <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><strong>同减操作!</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">incrbyfloat key value<span class="hljs-regexp">//</span>浮点数的加操作<br></code></pre></td></tr></table></figure><blockquote><p>精度保留17位,<strong><em>进1法</em></strong>舍去17位之后的数<br><img src="/img/redis-learning/String/redis24.PNG" alt="incrbyfloat"></p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><h1 id="List类型的操作"><a href="#List类型的操作" class="headerlink" title="List类型的操作"></a>List类型的操作</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p><img src="/img/redis-learning/List/1.PNG" alt="内存模型"><br><strong>相当于java中的list集合,元素有序,且可以重复</strong><br>Redis中List是个堆栈，也遵循FILO（先进后出）的原则.</p><h2 id="创建、遍历列表"><a href="#创建、遍历列表" class="headerlink" title="创建、遍历列表"></a>创建、遍历列表</h2><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">lpush <span class="hljs-built_in">key</span> [value...] //从左<span class="hljs-built_in">push</span><br>lpushx <span class="hljs-built_in">key</span> [value...] //从左<span class="hljs-built_in">push</span>,且<span class="hljs-built_in">key</span>是已经存在的<br>rpush <span class="hljs-built_in">key</span> [value...] //从右<span class="hljs-built_in">push</span><br>rpushx <span class="hljs-built_in">key</span> [value...] //从右<span class="hljs-built_in">push</span>,且<span class="hljs-built_in">key</span>是已经存在的<br></code></pre></td></tr></table></figure><p><strong>lpush最后入栈的元素就是栈首<br>rpush最后入栈的元素就是栈尾</strong></p><ul><li>push成功后返回堆栈长度</li><li>pushx如果key不存在，不会报错，返回0表示key对应的堆栈不存在，如果存在，返回push后的堆栈长度</li><li>pushx不能创建列表<h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lrange</span> key start end //遍历某一区间的列表(从栈首遍历)<br></code></pre></td></tr></table></figure><img src="/img/redis-learning/List/2.PNG" alt="push&amp;range"></li></ul><hr><h2 id="移除列表元素"><a href="#移除列表元素" class="headerlink" title="移除列表元素"></a>移除列表元素</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">lpop key <span class="hljs-regexp">//</span>移除并返回栈首的元素<br>rpop key <span class="hljs-regexp">//</span>移除并返回栈尾的元素<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/List/3.PNG" alt="pop"></p><hr><h2 id="获取列表长度"><a href="#获取列表长度" class="headerlink" title="获取列表长度"></a>获取列表长度</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">llen key</span><br></code></pre></td></tr></table></figure><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lset</span> key index newvalue<br></code></pre></td></tr></table></figure><blockquote><p>修改的是key对应列表中索引为index的值,即 <strong>list[index]</strong> 的值</p></blockquote><p><img src="/img/redis-learning/List/4.PNG" alt="set"></p><hr><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lindex</span> key index<br></code></pre></td></tr></table></figure><p><strong>获取list[index]的元素</strong><br><img src="/img/redis-learning/List/5.PNG" alt="set"></p><hr><h2 id="删除重复元素"><a href="#删除重复元素" class="headerlink" title="删除重复元素"></a>删除重复元素</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">lrem <span class="hljs-built_in">key</span> <span class="hljs-built_in">count</span> <span class="hljs-built_in">value</span><br></code></pre></td></tr></table></figure><p><strong>从左遍历列表，删除count个重复的元素value</strong></p><ul><li>如果value不存在，则不会报错，只是返回0</li><li>如果value存在，返回的是删除的value个数</li></ul><p><img src="/img/redis-learning/List/6.PNG" alt="rem"></p><hr><h2 id="截取列表"><a href="#截取列表" class="headerlink" title="截取列表"></a>截取列表</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">ltrim<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>截取list中start到end的部分</strong></p><ul><li>截取后key对应的列表<strong>被替换成原先列表中截取的部分</strong>，且截取部分的元素<strong>索引也会从0开始从新编号</strong></li><li>如果截取部分的索引 <strong>不在list的范围内(超出范围)</strong> 那么截取操作的结果也是OK的！！！  <strong>不会报错</strong> ，但截取后key的列表为空(截取部分为空，所以列表也为空)</li></ul><p><img src="/img/redis-learning/List/7.PNG" alt="trim"></p><hr><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">linsert</span> key before value //在<span class="hljs-keyword">list</span>中的before元素前插入value<br><span class="hljs-keyword">linsert</span> key <span class="hljs-keyword">after</span> value //在<span class="hljs-keyword">list</span>中的<span class="hljs-keyword">after</span>元素后插入value<br></code></pre></td></tr></table></figure><ul><li><strong>如果list中存在重复的before(after)元素，则会选取从左遍历的第一个出现的before(after)元素</strong></li><li>返回插入元素后列表的长度</li></ul><p><img src="/img/redis-learning/List/8.PNG" alt="insert"></p><hr><h1 id="Set类型的操作"><a href="#Set类型的操作" class="headerlink" title="Set类型的操作"></a>Set类型的操作</h1><h2 id="内存模型-1"><a href="#内存模型-1" class="headerlink" title="内存模型"></a>内存模型</h2><p><img src="/img/redis-learning/Set/1.PNG" alt="内存模型"><br><strong>特点：是一个元素无序，且元素不可重复的集合</strong></p><h2 id="集合的创建与遍历"><a href="#集合的创建与遍历" class="headerlink" title="集合的创建与遍历"></a>集合的创建与遍历</h2><h3 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sadd</span> key value or<span class="hljs-meta"> [value...]</span><br></code></pre></td></tr></table></figure><ul><li><strong>创建时，如果value中有重复的，也能成功创建，重复的value会自动的忽略</strong></li><li>创建后返回集合的大小</li></ul><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">smembers key</span><br></code></pre></td></tr></table></figure><p><strong>注意！这里输出是有序的是因为Redis会自动比较值大小再输出！并不改变集合本身！这个集合的底层仍是无序的！这与集合的特点不矛盾！</strong><br><img src="/img/redis-learning/Set/2.PNG" alt="sadd&amp;smembers"></p><h2 id="查看集合的大小"><a href="#查看集合的大小" class="headerlink" title="查看集合的大小"></a>查看集合的大小</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scard key</span><br></code></pre></td></tr></table></figure><ul><li>返回集合大小</li></ul><h2 id="元素的删除"><a href="#元素的删除" class="headerlink" title="元素的删除"></a>元素的删除</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">spop <span class="hljs-built_in">key</span> <span class="hljs-built_in">count</span> <span class="hljs-comment">//随机删除</span><br>srem <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span> <span class="hljs-built_in">or</span> [<span class="hljs-built_in">value</span>....] <span class="hljs-comment">//删除一个或多个指定元素</span><br></code></pre></td></tr></table></figure><ul><li>在集合中spop随机选取count个元素删除，并返回删除的元素,srem则是删除指定的元素</li><li>spop如果删除的个数超过集合的大小，则默认将集合的所有元素删除</li><li>srem如果删除的元素不存在，则不会执行删除操作，返回0<br><img src="/img/redis-learning/Set/3.PNG" alt="pop"></li></ul><hr><p><img src="/img/redis-learning/Set/4.PNG" alt="pop"></p><hr><p><img src="/img/redis-learning/Set/6.PNG" alt="rem"></p><hr><h2 id="元素的移动"><a href="#元素的移动" class="headerlink" title="元素的移动"></a>元素的移动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">smove <span class="hljs-built_in">source</span> destination member<br></code></pre></td></tr></table></figure><ul><li>只能用于集合之间的元素移动</li><li>移动不存在的member不会报错，返回0(不发生移动)</li><li>移动后，返回移动元素的个数（一次移一个）</li></ul><p><img src="/img/redis-learning/Set/5.PNG" alt="smove"></p><hr><h2 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sismember <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure><h2 id="随机返回元素"><a href="#随机返回元素" class="headerlink" title="随机返回元素"></a>随机返回元素</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">srandmember </span>key <span class="hljs-built_in">count</span><br></code></pre></td></tr></table></figure><ul><li>随机返回集合中的count个元素</li></ul><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sdiff akey <span class="hljs-keyword">bkey </span><span class="hljs-keyword">or </span>[<span class="hljs-keyword">bkey...]</span><br></code></pre></td></tr></table></figure><ul><li>求出akey和bkey的减集(去除akey集合中其他bkey集合中<strong>相同的</strong>元素)</li><li>这个操作不会删除集合的元素，只是计算！</li></ul><h2 id="求交集"><a href="#求交集" class="headerlink" title="求交集"></a>求交集</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sinter akey bkey</span><br></code></pre></td></tr></table></figure><h2 id="求并集"><a href="#求并集" class="headerlink" title="求并集"></a>求并集</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sunion akey bkey</span><br></code></pre></td></tr></table></figure><hr><h1 id="ZSet类型的操作"><a href="#ZSet类型的操作" class="headerlink" title="ZSet类型的操作"></a>ZSet类型的操作</h1><h2 id="内存模型-2"><a href="#内存模型-2" class="headerlink" title="内存模型"></a>内存模型</h2><p>特点: 可排序，不重复的set集合 (sortSet) 靠分数排序,不靠元素排序<br><strong>其本质仍然是set，set本身不可排序，靠分数才会让set有序</strong><br><img src="/img/redis-learning/ZSet/1.PNG"></p><hr><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">zadd</span> key<span class="hljs-meta"> [score value ... ]</span><br></code></pre></td></tr></table></figure><ul><li>如果创建了重复的key，则最后创建的会覆盖最先创建的</li><li>创建成功后，返回zset大小</li><li>创建成功后，会自动根据分数进行排序<h2 id="查看大小"><a href="#查看大小" class="headerlink" title="查看大小"></a>查看大小</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">zcard key</span><br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">zrange<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> [withscores] //遍历某一范围内的元素，可选是否显示分数<br>zrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span> [withscores] [limit <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>] //遍历某一分数范围内的元素，可选是否选择分数，是否展示<span class="hljs-keyword">start</span>到<span class="hljs-keyword">end</span>的查找结果<br></code></pre></td></tr></table></figure><h2 id="查看排名"><a href="#查看排名" class="headerlink" title="查看排名"></a>查看排名</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> //查看集合中<span class="hljs-built_in">member</span>的排名<br>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> //查看集合中<span class="hljs-built_in">member</span>的倒序排名<br></code></pre></td></tr></table></figure></li><li>排名从0开始排</li><li>排名根据分数来排，并非元素本身！</li></ul><h2 id="查看元素分数"><a href="#查看元素分数" class="headerlink" title="查看元素分数"></a>查看元素分数</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> //查看集合中<span class="hljs-built_in">member</span>的分数<br></code></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zrem <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> <span class="hljs-keyword">or</span> [<span class="hljs-built_in">member</span>...] //移除一个或多个<span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure><ul><li>移除不存在的元素只会返回0</li></ul><h2 id="加分"><a href="#加分" class="headerlink" title="加分"></a>加分</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span> // 给特定的<span class="hljs-built_in">member</span>增加increment分<br></code></pre></td></tr></table></figure><ul><li>这个increment分可以带小数</li><li>返回值是增加后member的分数</li></ul><h1 id="Hash类型的操作"><a href="#Hash类型的操作" class="headerlink" title="Hash类型的操作"></a>Hash类型的操作</h1><h2 id="内存模型-3"><a href="#内存模型-3" class="headerlink" title="内存模型"></a>内存模型</h2><p>特点: key对应的value还是key-value型的值，Map&lt;key,Map&lt;key,value&gt;&gt; map（套娃）,这个套娃的map结构的key无序</p><p>!()[/img/redis-learning/ZSet/2.png]</p><h2 id="创建添加"><a href="#创建添加" class="headerlink" title="创建添加"></a>创建添加</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hset</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value...] <br><span class="hljs-symbol">hsetnx</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value...] <span class="hljs-comment">//最大的区别是如果字段存在，则不会进行覆盖操作，如果不存在，则进行添加操作</span><br></code></pre></td></tr></table></figure><ul><li>创建成功后返回field-value的个数</li><li>如果创建的key有重复，则不会覆盖，如果创建的field有重复，则最后创建的会覆盖最新创建的</li></ul><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">hget key field <span class="hljs-regexp">//</span>获取key中字段名为field的value<br>hgetall key <span class="hljs-regexp">//</span>获取key的所有字段和value<br></code></pre></td></tr></table></figure><h2 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">hdel <span class="hljs-built_in">key</span> field <span class="hljs-keyword">or</span> [field...] //删除<span class="hljs-built_in">key</span>中的一个或多个字段<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">or</span> [<span class="hljs-built_in">key</span>...] //删除整个<span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="判断key"><a href="#判断key" class="headerlink" title="判断key"></a>判断key</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">hexists<span class="hljs-built_in"> key</span> field //判<span class="hljs-built_in">断key</span>中的field字段是否存在<br>exists<span class="hljs-built_in"> key</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">[key</span>...] //判<span class="hljs-built_in">断key</span>存不存在<br></code></pre></td></tr></table></figure><h2 id="获取所有key"><a href="#获取所有key" class="headerlink" title="获取所有key"></a>获取所有key</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hkeys key <span class="hljs-regexp">//</span>获取key的所有字段名<br></code></pre></td></tr></table></figure><h2 id="获取所有vals"><a href="#获取所有vals" class="headerlink" title="获取所有vals"></a>获取所有vals</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hvals key <span class="hljs-regexp">//</span>获取key中所有的value<br></code></pre></td></tr></table></figure><p><strong>hgetall就是hkeys+hvals的整合，注意区别</strong></p><h2 id="设置多个field-value"><a href="#设置多个field-value" class="headerlink" title="设置多个field-value"></a>设置多个field-value</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hmset</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value...]<br></code></pre></td></tr></table></figure><p><strong>hset现在也能一次放多个field value</strong></p><h2 id="获取多个key-value"><a href="#获取多个key-value" class="headerlink" title="获取多个key-value"></a>获取多个key-value</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hmget</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value ...]<br></code></pre></td></tr></table></figure><h2 id="加操作-1"><a href="#加操作-1" class="headerlink" title="加操作"></a>加操作</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hincrby</span> key <span class="hljs-meta">field</span> increment <span class="hljs-comment">//为字段增加整数数值</span><br><span class="hljs-symbol">hincrbyfloat</span> key <span class="hljs-meta">field</span> increment <span class="hljs-comment">//为字段增加浮点数数值</span><br></code></pre></td></tr></table></figure><ul><li>如果这个字段的value不是整型或浮点型，操作会失败</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>学个命令也学了两天，看来👴是真的拉跨，但还是要学啊，学着先吧</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始Redis</title>
    <link href="/2021/02/10/%E5%88%9D%E5%A7%8BRedis/%E5%88%9D%E5%A7%8BRedis/"/>
    <url>/2021/02/10/%E5%88%9D%E5%A7%8BRedis/%E5%88%9D%E5%A7%8BRedis/</url>
    
    <content type="html"><![CDATA[<h1 id="初学Redis"><a href="#初学Redis" class="headerlink" title="初学Redis"></a>初学Redis</h1><blockquote><p>在每学习一门新技术前，了解它是用于解决什么问题的？怎么解决的？应用场景是啥？与别的技术比，又有啥优势？往往能够对这个技术有个非常好的自我认知与定位</p></blockquote><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>基于<strong>内存</strong>进行储存，操作的是内存中的数据</li><li>支持<strong>key-value</strong>的储存形式</li><li>底层是用<strong>C语言</strong>编写的</li><li>NoSQL类数据库(Not only SQL) 非关系型数据库</li><li>Redis的操作都是<strong>原子性</strong>的，要么都执行成功，要么都执行失败</li><li>支持数据持久化机制(也是Redis称为数据库的重要原因)</li><li>是单进程，单线程的设计（不支持并发，不存在线程安全问题） –&gt; 设计分布式锁</li></ul><blockquote><p>所以可知Redis的运行处理效率非常高,而且没有数据表的概念,直接用key-value的形式完成对数据的管理</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>数据模型比较简单</li><li>对数据库性能要求较高</li><li>不需要高度的数据一致性（NoSQL对事务支持不是很好）</li><li>…等等</li></ul><h2 id="支持的5种数据类型"><a href="#支持的5种数据类型" class="headerlink" title="支持的5种数据类型"></a>支持的5种数据类型</h2><ul><li>String 字符串</li><li>List 列表</li><li>Set 无序集合</li><li>ZSet 有序集合</li><li>Hash 哈希</li></ul><blockquote><p>哈希的结构在Redis中很特殊，其结构为<br><strong>Key : { Key : value }</strong></p></blockquote><h2 id="Redis的安装与使用-Windows环境"><a href="#Redis的安装与使用-Windows环境" class="headerlink" title="Redis的安装与使用(Windows环境)"></a>Redis的安装与使用(Windows环境)</h2><p>Redis的安装是我们接触Redis时出现的第一个难题</p><p><strong>注意</strong><br></p><blockquote><p>Redis官方是没有windows环境下的安装包的!也就是说，要想使用原生的Redis，只能在Linux环境下使用!<br><strong>(微软其实做过Windows下的Redis环境，但GitHub上的代码很久没更新，说明可能弃坑了！)</strong>.</p></blockquote><p><br>那么，使用windows的用户是不是用不了呢？并不是！<br><br><strong>以下有三种方法能够在Windows下使用Redis！</strong></p><ol><li>通过<strong>虚拟机</strong>来使用Redis</li><li>通过安装<strong>WSL</strong>来使用Redis </li><li>通过安装Github上其他大神的Redis包，来使用redis<br>链接如下:<a href="https://github.com/tporadowski/redis/releases">Redis Install</a></li></ol><p>上面三种方法怎么选呢？我的意见如下:</p><ul><li>第一种:简单粗暴，但并不推荐，虚拟机占用资源十分大！如果两平台操作，难免会卡顿，影响操作体验,不介意者推荐使用！<br></li><li>第二种:WSL意思是Windows的子系统，这个子系统能够安装Linux的分发版，不同的是没有图形界面操作，只有命令行操作，所以占用空间小，但是安装过程以及配置操作较繁杂,没有耐心整的话也不推荐<br></li><li>第三种: 安装过程简单粗暴，使用也不复杂，缺点就是不是原生的，没有官方的技术支持，未知的bug和版本的小落后等，但对于正在学习的我们来说够用了<br></li></ul><blockquote><p><strong>注意</strong> 第三种方法的安装只支持64位系统！</p></blockquote><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤:"></a>安装步骤:</h3><blockquote><p>对于我来讲，第三种方法是最简便的<del>(老懒狗了)</del>，所以就简单的记录下，第三种的安装步骤</p></blockquote><ol><li>打开链接，选择msi安装包(原因看下面！)</li><li>下载好后，创建一个文件夹来存放redis，推荐放系统盘以外的盘</li><li>以管理员身份运行安装包(安装过程如果出现错误代码2502，2503，多半是权限不足),具体怎么以管理员身份运行，可以自行百度”以管理员身份运行msi文件”,</li><li>跟着提示走，Next，选定Redis存放位置(放在第二步创建的文件里),ADD PATH(省去自己配置环境变量的步骤，所以选msi文件安装，<del>我猜的</del>),整完这些后，提示安装成功就能退出安装程序了.</li></ol><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h3><ol><li>输入<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">redis-server</span> <span class="hljs-selector-tag">--service-install</span> <span class="hljs-selector-tag">redis</span><span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.conf</span><br></code></pre></td></tr></table></figure>部署Redis在windows下的服务(关闭cmd后redis服务就会自动关闭)</li><li>(配置好环境变量后)启动cmd命令行,输入<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span>.exe<br></code></pre></td></tr></table></figure>启动redis服务，命令台会出现相应的信息<img src="/img/redis-learning/String/redis1.PNG" alt="开启服务"></li><li>新开一个cmd<br>(第2步的cmd别关，否则无法访问redis服务端！)，输入<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">redis-<span class="hljs-keyword">cli</span>.exe <br></code></pre></td></tr></table></figure>开始访问redis(默认端口为6379)</li><li>输入ping，查看输出,输入 set a 111 存储键值对，输入get a取出键值对，查看输出结果</li><li>以上如果都能正常输出，那么就能正常使用redis <img src="/img/redis-learning/String/redis2.PNG" alt="输入和输出"></li></ol><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令:"></a>常用指令:</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-server --service-stop <span class="hljs-regexp">//</span>停止服务<br>redis-server --service-start <span class="hljs-regexp">//</span>开启服务<br>redis-server --service-uninstall <span class="hljs-regexp">//</span>卸载服务<br>redis-cli -p 端口号 --raw <span class="hljs-regexp">//</span>指定端口号启动，并让转化中文编码，显示中文<br></code></pre></td></tr></table></figure><h3 id="修改Redis配置"><a href="#修改Redis配置" class="headerlink" title="修改Redis配置"></a>修改Redis配置</h3><ul><li><p>启动端口修改: 安装目录下找到redis.windows-service.conf,打开后，搜索port,直接修改即可</p><blockquote><p>修改完后不能直接重新启动Redis!否则配置不会生效！应用命令<br></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">redis-server</span> <span class="hljs-selector-tag">redis</span><span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.conf</span><br></code></pre></td></tr></table></figure><p>使<strong>全部修改的配置</strong>生效！</p></li><li><p>database库</p><blockquote><p>存放数据的一个基本单元，每个库都能存放key-value键值对，redis中每个库都有独有的id，从0开始，redis默认有16个库(0-15号)，默认为0号库，每个库之间数据是独立的！</p></blockquote></li></ul><p><strong>库的数目也能修改，在redis.windows.conf中搜索databases 更改数字即可！</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">select 库id <span class="hljs-regexp">//</span>选择某个库<br>flushDB <span class="hljs-regexp">//</span>清空当前库的数据<br>flushAll <span class="hljs-regexp">//</span>清空全部库的数据<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis3.PNG" alt="FLUSHDB"></p><hr><p><img src="/img/redis-learning/String/redis4.PNG" alt="FLUSHALL"></p><hr><h2 id="操作KEY的指令"><a href="#操作KEY的指令" class="headerlink" title="操作KEY的指令"></a>操作KEY的指令</h2><h3 id="删除key"><a href="#删除key" class="headerlink" title="删除key"></a>删除key</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">del</span> [<span class="hljs-built_in">key</span>...]<br></code></pre></td></tr></table></figure><ul><li>删除一个或多个key，不存在的会被忽略</li><li>返回删除key的数量<br><img src="/img/redis-learning/String/redis5.PNG" alt="del key"></li></ul><hr><h3 id="检查key存在与否"><a href="#检查key存在与否" class="headerlink" title="检查key存在与否"></a>检查key存在与否</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">exists</span> key<br></code></pre></td></tr></table></figure><ul><li>若key存在返回1，反之返回0<br><img src="/img/redis-learning/String/redis6.PNG" alt="exists key"></li></ul><hr><h3 id="设置key存活时间"><a href="#设置key存活时间" class="headerlink" title="设置key存活时间"></a>设置key存活时间</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">expire key seconds <span class="hljs-regexp">//</span>以秒为单位<br>pexpire key millsseconds <span class="hljs-regexp">//</span>以毫秒为单位<br>pexpireat key milliseconds <span class="hljs-regexp">//</span>以毫秒为单位的unix时间戳<br></code></pre></td></tr></table></figure><ul><li>设置key存活时间(秒)，一旦过期，key就会被删除</li><li>设置成功返回1，反之返回0</li><li>时间复杂度O(1)</li></ul><p><img src="/img/redis-learning/String/redis7.PNG" alt="expire key"></p><hr><h3 id="查看key剩余存活时间"><a href="#查看key剩余存活时间" class="headerlink" title="查看key剩余存活时间"></a>查看key剩余存活时间</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ttl key <span class="hljs-regexp">//</span>以秒为单位<br>pttl KEY <span class="hljs-regexp">//</span>以毫秒为单位<br></code></pre></td></tr></table></figure><ul><li>查看对应key的剩余存活时间</li><li>返回-1，key存活时间为永久，返回-2，key不存在，返回&gt;=0，key的剩余存活时间</li></ul><p><img src="/img/redis-learning/String/redis11.PNG" alt="ttl"></p><h3 id="keys匹配"><a href="#keys匹配" class="headerlink" title="keys匹配"></a>keys匹配</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">例子<br>keys * <span class="hljs-regexp">//</span> 匹配所有keys<br>keys h?llo <span class="hljs-regexp">//</span>匹配hello,hallo,hxllo等  ?--&gt;匹配一个字符<br>keys h*llo <span class="hljs-regexp">//</span>匹配hllo和heeeeello等 *--&gt;匹配多个字符<br>keys h[ae]llo <span class="hljs-regexp">//</span>匹配hallo,hello,不匹配hllo,特殊符号用\隔开<br></code></pre></td></tr></table></figure><ul><li>返回符合匹配的key列表<br><img src="/img/redis-learning/String/redis8.PNG" alt="keys"></li></ul><hr><h3 id="key的移动"><a href="#key的移动" class="headerlink" title="key的移动"></a>key的移动</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">move</span> key dbid<br></code></pre></td></tr></table></figure><ul><li>移动成功返回1，反之返回0<br><img src="/img/redis-learning/String/redis9.PNG" alt="移动成功"></li></ul><hr><p><img src="/img/redis-learning/String/redis10.PNG" alt="移动失败"></p><hr><h3 id="randomkey"><a href="#randomkey" class="headerlink" title="randomkey"></a>randomkey</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">randomkey</span><br></code></pre></td></tr></table></figure><ul><li>当数据库不为空，随机返回一个key，为空则返回nil</li></ul><p><img src="/img/redis-learning/String/redis12.PNG" alt="randomkey"></p><hr><h3 id="key的重命名"><a href="#key的重命名" class="headerlink" title="key的重命名"></a>key的重命名</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">rename</span> <span class="hljs-built_in">key</span> newkey<br></code></pre></td></tr></table></figure><ul><li>将key重命名为newkey,如果key和newkey相同，或者key不存在，返回错误，如果newkey存在，则会覆盖旧值(key对应的value会被newkey对应的value覆盖)<br><img src="/img/redis-learning/String/redis13.PNG" alt="rename"></li></ul><hr><h3 id="查看key的值类型"><a href="#查看key的值类型" class="headerlink" title="查看key的值类型"></a>查看key的值类型</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> keyname<br></code></pre></td></tr></table></figure><ul><li>返回对应key的value的类型<blockquote><p>返回值: <br>none(不存在) <br> string(字符串)<br> list(列表)<br> set(集合)<br> zset(有序集合)<br> hash(哈希)<br></p></blockquote></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>上手学就翻车，好家伙，安装redis这一步就整了好久，初学下来就只记得redis的特点和安装步骤，希望👴没事。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Markdown</title>
    <link href="/2021/02/08/%E5%88%9D%E8%AF%86Markdown/%E5%88%9D%E8%AF%86Markdown/"/>
    <url>/2021/02/08/%E5%88%9D%E8%AF%86Markdown/%E5%88%9D%E8%AF%86Markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown的语法"><a href="#Markdown的语法" class="headerlink" title="Markdown的语法"></a>Markdown的语法</h1><blockquote><p>Markdown是一门标记性的语言，也是我用来写博客必须学会的，所以该博文用于记录Markdown的各种语法，并学会使用Markdown.</p></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//代码块语法:</span><br><span class="hljs-string">&#x27; ```Shell:  代码部分 ``` &#x27;</span><br><span class="hljs-comment">//或者直接使用: </span><br><span class="hljs-string">``</span><span class="hljs-string">` 代码部分  `</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure><h3 id="Java的代码块"><a href="#Java的代码块" class="headerlink" title="Java的代码块"></a>Java的代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//用 ``` Java  ``` 即可生成Java样式的代码块，其他语言同理 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello Markdown!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C系的代码块"><a href="#C系的代码块" class="headerlink" title="C系的代码块"></a>C系的代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Hello Markdown!&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell">//Linux下的命令<br>pwd<br>mkdir<br>touch<br>gcc...<br></code></pre></td></tr></table></figure><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote><p>标题用#号来表示标题，其对应了HTML的5个H标题</p></blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># ---&gt; h1 一级标题<br>## ---&gt; h2 二级标题<br>### ---&gt; h3 三级标题<br>#### ---&gt; h4 四级标题<br>##### ---&gt; h5 五级标题<br>###### ---&gt; h6 六级标题<br></code></pre></td></tr></table></figure><h2 id="与字体有关的语法"><a href="#与字体有关的语法" class="headerlink" title="与字体有关的语法"></a>与字体有关的语法</h2><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**内容**</span> 加粗字体,内容跟*号不分离<br></code></pre></td></tr></table></figure><p><strong>Hello Markdown!</strong> </p><h3 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*内容*</span> 倾斜字体<br></code></pre></td></tr></table></figure><p><em>Hello Markdown!</em></p><h3 id="字体高亮"><a href="#字体高亮" class="headerlink" title="字体高亮"></a>字体高亮</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">=<span class="ruby">=内容== 高亮内容</span><br></code></pre></td></tr></table></figure><p>==Hello Markdown!==</p><h3 id="内容删除样式"><a href="#内容删除样式" class="headerlink" title="内容删除样式"></a>内容删除样式</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~内容~~ 显示删除样式<br></code></pre></td></tr></table></figure><p><del>Hello Markdown!</del></p><h2 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> 内容</span> <br><span class="hljs-meta">&gt;</span><span class="bash">&gt; 内容</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; 内容</span><br>输出效果见下面<br></code></pre></td></tr></table></figure><blockquote><p>Hello Markdown!</p><blockquote><p>Hello Markdown!</p><blockquote><p>Hello Markdown!</p></blockquote></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//全屏分割线</span><br><span class="hljs-string">***</span><br><span class="hljs-string">//部分分割线</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><hr><hr><h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//在线图片，本体图片的插入</span><br>!<span class="hljs-selector-attr">[图片名]</span>(图片地址)<br></code></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1229424709,3319526529&fm=26&gp=0.jpg" alt="在线图片样例"></p><blockquote><p>在线图片会涉及到版权，图床的选择等问题！</p></blockquote><hr><p><img src="/img/default.png" alt="本地图片样例"></p><blockquote><p>本地图片的路径是相对路径！且图片存放路径在/public/img下!</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[链接名](地址)<br></code></pre></td></tr></table></figure><p><a href="https://github.com/kolvzaki">My GitHub</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>无序列表<br>- 目录<span class="hljs-number">1</span><br>- 目录<span class="hljs-number">2</span><br>...<br><span class="hljs-regexp">//</span>有序列表<br>序号.名称<br><span class="hljs-number">1</span>.首页<br><span class="hljs-number">2</span>.目录<br><span class="hljs-number">3</span>.... <br></code></pre></td></tr></table></figure><ul><li>目录1</li><li>目录2</li><li>目录3</li></ul><p>1.首页<br>2.分类<br>3.目录</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 标题1 </span>|<span class="hljs-string"> 标题2   </span>|<span class="hljs-string"> 长长的标题3 </span>|<span class="hljs-string"> title 4 </span>|<br>|<span class="hljs-string"> ----- </span>|<span class="hljs-string"> --------- </span>|<span class="hljs-string"> ----------- </span>|<span class="hljs-string"> ------- </span>|<br>|<span class="hljs-string"> 内容1 </span>|<span class="hljs-string"> content 2 </span>|<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<br>|<span class="hljs-string"> 行3  </span>|<span class="hljs-string"> line3     </span>|<span class="hljs-string"> column 3    </span>|<span class="hljs-string">         </span>|<br></code></pre></td></tr></table></figure><blockquote><p>生成表格语法很麻烦，建议上网搜相关的快速生成</p></blockquote><table><thead><tr><th>标题1</th><th>标题2</th><th>长长的标题3</th><th>title 4</th></tr></thead><tbody><tr><td>内容1</td><td>content 2</td><td></td><td></td></tr><tr><td>行3</td><td>line3</td><td>column 3</td><td></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是👴某种意义上的第一篇博文，也是新的开始，整来这东西希望能改一哈👴的懒癌，再懒下去👴要无了，学习的路线都规划好了，希望不会🕊</p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/06/hello-world/"/>
    <url>/2021/02/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
