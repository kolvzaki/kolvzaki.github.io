<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实训笔记</title>
    <link href="/2021/03/20/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/20/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="微服务分布式开发"><a href="#微服务分布式开发" class="headerlink" title="微服务分布式开发"></a>微服务分布式开发</h2><ol><li>Springboot+Springcloud   基于Restful风格服务</li><li>Dubbo  阿里开源</li></ol>]]></content>
    
    
    <categories>
      
      <category>实训</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习</title>
    <link href="/2021/03/15/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/03/15/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h1><p><strong>在使用命令时，要先开启Docker服务！否则不生效</strong></p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span><br>docker version<br></code></pre></td></tr></table></figure><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--help</span><br>docker<br></code></pre></td></tr></table></figure><h2 id="查看本地仓库所有镜-images"><a href="#查看本地仓库所有镜-images" class="headerlink" title="查看本地仓库所有镜(images)"></a>查看本地仓库所有镜(images)</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">docker images <span class="hljs-comment">(+镜像名)</span><br></code></pre></td></tr></table></figure><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">docker pull 镜像名:<span class="hljs-keyword">version</span> <span class="hljs-comment">//配合docker hub下载需要的镜像,默认下载最新版本</span><br>docker pull 镜像名:<span class="hljs-keyword">@DIGEST</span>（摘要）<br></code></pre></td></tr></table></figure><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">docker <span class="hljs-built_in">search</span> 镜像名<br></code></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">image</span> rm 镜像名:version<br>docker <span class="hljs-keyword">image</span> rm 镜像名:镜像id<br>docker <span class="hljs-keyword">image</span> rm -f <span class="hljs-comment">//强行删除</span><br>docker rmi (-f) <span class="hljs-comment">//简写删除</span><br>docker rmi -f $(docker images -q) <span class="hljs-comment">//全部删除</span><br></code></pre></td></tr></table></figure><h2 id="镜像帮助命令"><a href="#镜像帮助命令" class="headerlink" title="镜像帮助命令"></a>镜像帮助命令</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">image</span> --<span class="hljs-keyword">help</span><br></code></pre></td></tr></table></figure><h1 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h1><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> 镜像名：tag||：镜像id</span><br>docker <span class="hljs-keyword">run</span><span class="bash"> -p port1(宿主机端口):port2(容器内服务监听的端口) 镜像名 //-p用于将宿主机端口与容器端口进行映射</span><br>docker <span class="hljs-keyword">run</span><span class="bash"> -d 镜像名//-d 后台启动容器，不输出日志，返回容器id </span><br>docker <span class="hljs-keyword">run</span><span class="bash"> --name 镜像名 //为启动容器起一个唯一的识别名(系统默认生成)</span><br></code></pre></td></tr></table></figure><p><strong>docker本身使用了虚拟化机制，其内部的容器运行在一个沙盒中，是与宿主机隔离的！所以访问沙盒中某个端口时，需要进行映射</strong><br><strong>容器与容器之间是隔离的！且是系统级别的隔离，所以运行在同一个端口也是可行的！但不能映射同一个宿主机端口！！！</strong></p><h2 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker ps<br>docker ps -a <span class="hljs-regexp">//</span>查看所有运行以及未运行的容器<br>docker ps -q <span class="hljs-regexp">//</span>查看正在运行的容器id<br>docker ps -qa <span class="hljs-regexp">//</span>前两条命令的结合<br></code></pre></td></tr></table></figure><h2 id="停止-重启"><a href="#停止-重启" class="headerlink" title="停止,重启"></a>停止,重启</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker start 容器名<span class="hljs-string">||容器ID</span><br>docker restart 容器名<span class="hljs-string">||容器ID</span><br>docker stop 容器名<span class="hljs-string">||容器ID</span><br>docker kill 容器名<span class="hljs-string">||容器ID //与stop的区别是，该命令马上关闭该容器，stop是正常关闭</span><br></code></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> 容器名||容器id //只能删除没运行的容器<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 容器名||容器id //删除正在运行的容器<br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-qa</span>) //删除所有容器<br></code></pre></td></tr></table></figure><h2 id="查看容器内服务日志"><a href="#查看容器内服务日志" class="headerlink" title="查看容器内服务日志"></a>查看容器内服务日志</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">docker logs 容器名||容器<span class="hljs-symbol">id</span><br>docker logs -f 容器名||容器<span class="hljs-symbol">id</span> <span class="hljs-comment">//实时展示容器服务日志</span><br>docker logs -t 容器名||容器<span class="hljs-symbol">id</span> <span class="hljs-comment">//加入时间戳</span><br>docker logs --tail number 容器名||容器<span class="hljs-symbol">id</span> <span class="hljs-comment">//显示最后number行日志</span><br></code></pre></td></tr></table></figure><h2 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">docker <span class="hljs-built_in">top</span> 容器名|<span class="hljs-type">|容器id</span><br></code></pre></td></tr></table></figure><h2 id="与容器进行交互"><a href="#与容器进行交互" class="headerlink" title="与容器进行交互"></a>与容器进行交互</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it 容器名||容器id bash <span class="hljs-regexp">//</span>以bash交互方式进行交互，不能缺少！<br><span class="hljs-keyword">exit</span> <span class="hljs-regexp">//</span>退出交互<br></code></pre></td></tr></table></figure><h2 id="容器复制文件到操作系统"><a href="#容器复制文件到操作系统" class="headerlink" title="容器复制文件到操作系统"></a>容器复制文件到操作系统</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qml">docker cp 容器<span class="hljs-attribute">id:</span><span class="hljs-string">容器内的资源路径 操作系统中的路径</span><br><span class="hljs-string">docker</span> cp 宿主机的资源 容器<span class="hljs-attribute">id:</span><span class="hljs-string">容器路径</span><br></code></pre></td></tr></table></figure><h2 id="查看容器的具体信息"><a href="#查看容器的具体信息" class="headerlink" title="查看容器的具体信息"></a>查看容器的具体信息</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker inspect 容器<span class="hljs-built_in">id</span>||容器<span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><h2 id="数据卷-Volume"><a href="#数据卷-Volume" class="headerlink" title="数据卷 Volume"></a>数据卷 Volume</h2><p><strong>作用：</strong><br></p><ol><li>实现宿主机与容器之间的文件共享</li><li>持久化数据(Redis,MySQL等)</li></ol><p>**使用:**启动容器时启用！启动后不能启用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -v 宿主机目录:容器内目录</span><br></code></pre></td></tr></table></figure><ol><li>自定义数据卷目录 （该方法会自动清空容器目录中的内容）</li><li>自动创建数据卷目录 (该方法如果宿主机目录不存在，会自动创建该目录，并创建映射，然后再把这个容器映射的目录中的内容，复制到宿主机目录中)</li></ol><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker commit -m <span class="hljs-string">&quot;描述&quot;</span> -a <span class="hljs-string">&quot;作者&quot;</span> 容器id<span class="hljs-string">||容器名称 打包的名称:镜像标签</span><br></code></pre></td></tr></table></figure><h2 id="备份镜像"><a href="#备份镜像" class="headerlink" title="备份镜像"></a>备份镜像</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">docker <span class="hljs-keyword">save</span> 镜像名称:标签 -o 文件名<br></code></pre></td></tr></table></figure><h2 id="载入容器"><a href="#载入容器" class="headerlink" title="载入容器"></a>载入容器</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">docker <span class="hljs-keyword">load</span> -i 容器名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式</title>
    <link href="/2021/03/01/Redis%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2021/03/01/Redis%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习分布式缓存之前，还应了解<strong>什么是分布式缓存</strong></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>本地缓存</strong>:储存在应用服务器中的数据(My batis)<br><strong>分布式缓存</strong>:储存在应用服务器外的数据(Redis)<br><strong>集群</strong>:<strong>同一种服务</strong>的多个节点在一起对系统提供服务的过程<br><strong>分布式</strong>:<strong>多个不同服务的集群</strong>共同对系统提供服务的系统称为分布式系统<br>(分布式是建立在集群的基础上的)</p><h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><h2 id="分布式缓存的优点"><a href="#分布式缓存的优点" class="headerlink" title="分布式缓存的优点"></a>分布式缓存的优点</h2><p>服务器宕机或电源断电时，也能够保证数据不会丢失（这也是本地缓存最大的问题）。做到分布式系统的数据共享。</p><h2 id="分布式缓存的实现"><a href="#分布式缓存的实现" class="headerlink" title="分布式缓存的实现"></a>分布式缓存的实现</h2><p>Mybatis二级缓存+Redis实现分布式缓存</p><blockquote><ul><li>在mapper中用<cache/>标签开启二级缓存</li><li>自定义一个cache类替换默认的cache实现类</li><li><cache-ref/>适用于多表查询,实现多表缓存共享(关联关系缓存处理)</li></ul></blockquote><h2 id="缓存的优化策略"><a href="#缓存的优化策略" class="headerlink" title="缓存的优化策略"></a>缓存的优化策略</h2><ul><li>对放入Redis的key优化，key的长度不能过长   **策略:**MD5摘要算法进行处理<blockquote><ul><li>MD5算法特点: </li></ul></blockquote><ol><li>一切文件字符串经过MD5处理后，都会生成32位16进制字符串</li><li>不同内容文件经过md5进行加密，加密结果大概率不一致。 （面试经典问题）</li><li>相同内容经过加密，其加密结果一定一致</li></ol></li></ul><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>缓存穿透</li><li>缓存雪崩</li><li>缓存击穿</li><li>解决方法</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>用户<strong>不断</strong>发送请求查询一个缓存和数据库中都<strong>不存在的数据</strong>，导致缓存无法利用的情况叫缓存穿透。此时请求会直接访问数据库，如果请求数量十分巨大，则会导致数据库访问压力大，容易出现宕机挂掉，访问慢等问题。</p><p>解决方法: 用mybatis的cache去解决，将在数据库中没有查询到的结果也进行缓存(key-null),就算下次再进行这个key的查询,也能从cache返回null。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>某一个</strong>热点key在某个时间点过期的时候，被大量用户的并发请求进行访问，由于缓存中这个key过期不存在，从而请求会转向去DB加载数据，并进行新的缓存，此时，大量的并发请求可能会让DB压垮宕机。</p><p>解决方法:</p><ol><li>将热点key设为永不失效</li><li>在key即将过期时，通过异步线程重新设置热点key的生存时间</li><li>缓存获取为null时，对从数据库重新加载数据的过程进行上锁，防止请求压垮数据库(分布式锁)</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>某个时刻</strong>系统中的全部缓存失效，且客户端传来大量的请求，导致缓存无法利用，大量请求转向DB，导致DB阻塞，挂机，宕机的情况称为缓存雪崩</p><blockquote><p>当业务非常庞大时，不同模块的业务数据不同，在放入缓存时，都会设置一个生存时间<br>解决方法:</p></blockquote><ol><li>缓存永久储存 (业务大不推荐,占用内存)</li><li>不同的业务数据设置不同的生存时间（避免同时失效）</li></ol><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>用于解决数据的<strong>冗余备份</strong>,从节点则只用来同步数据.(没有自动故障转移!)<br><strong>主从架构中，从节点只同步读取数据！不进行写数据</strong></p><blockquote><p>从节点能写数据，但没有意义</p></blockquote><p>不常用，因为主节点宕机了，从节点不能顶替主节点，从而redis引入了哨兵机制</p><h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p>哨兵机制是Redis高可用性的解决方案<br><br>它能够监听所有主服务器及其从服务器，当监视的某个主服务器下线了，宕机了，处于不可用状态时，它能够自动将其这个主服务器下的从服务器升级为主服务器。其余从服务器则会变成新主服务器的从服务器。当原来的主服务器重新上线时，则会变成新主服务器的从服务器<br><strong>哨兵机制就是带有自动故障转移功能的主从架构</strong></p><h2 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>数据库名字 IP PORT 哨兵数量<br></code></pre></td></tr></table></figure><blockquote></blockquote><ul><li>只有一定数量的哨兵检测到主服务器确实宕机了，才会进行主从交换</li><li>多个数量的哨兵会根据选举机制，选出新的主服务器(防止脑裂问题)</li></ul><h2 id="哨兵运行-Windows环境"><a href="#哨兵运行-Windows环境" class="headerlink" title="哨兵运行(Windows环境)"></a>哨兵运行(Windows环境)</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> 主服务器下的sentinel.conf <span class="hljs-comment">--sentinel</span><br></code></pre></td></tr></table></figure><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul><li>不能处理单节点的并发压力问题(单节点处理高并发请求)</li><li>不能处理单节点的物理内存上限问题(单节点记录巨量的操作记录在AOF日志中,AOF会不断增大，直到占满磁盘)</li></ul><h2 id="解决局限性的方法"><a href="#解决局限性的方法" class="headerlink" title="解决局限性的方法"></a>解决局限性的方法</h2><p><strong>Redis集群</strong></p><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><blockquote><p>springboot操作哨兵时，要开启哨兵的远程连接模式</p></blockquote><h2 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h2><p><img src="/img/redis-learning/%E9%9B%86%E7%BE%A4/1.PNG" alt="集群"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol><li>Redis节点互相连接(Ping-Pong(心跳)机制)，内部用二进制协议优化传输速度和带宽</li><li>集群中超过一半数量以上的节点认为某个节点宕机时，才会确认这个节点宕机(节点建议奇数个，偶数可能会发生歧义)</li><li>客户端能与Redis节点直连，无需代理层，客户端只需连接Redis集群中的任意一个可用节点即可</li><li>对外服务的master节点叫物理节点</li><li>Redis集群把所有的物理节点映射到[0-16383]slot哈希槽(crc16算法)上(slot会被物理节点平均分配，且物理节点数量最大不超过16384)</li></ol><p><strong>CRC16算法</strong></p><ol><li>对集群模式下的所有key进行CRC16计算，计算结果在0-16383之间</li><li>对同一个key进行多次CRC16计算，结果始终一致</li><li>不同的key计算CRC16的结果可能一致</li><li>是能让数据储存在Redis集群中任意一节点的重要原因</li></ol><h2 id="集群创建-Windows环境"><a href="#集群创建-Windows环境" class="headerlink" title="集群创建(Windows环境)"></a>集群创建(Windows环境)</h2><h3 id="配置文件部分"><a href="#配置文件部分" class="headerlink" title="配置文件部分"></a>配置文件部分</h3><ol><li>创建一个主文件夹redis-cluster,用于存放集群的节点</li><li>以每个节点的端口号为名，创建文件夹，并放入redis配置文件</li><li>开始配置，将端口号设置好（比如设置6个节点，则port改为6379-6384），将生成的快照和aof文件名改为”dump-xxxx”,”aof-xxxx”的格式，便于区分</li><li>将bind设置为统一IP（127.0.0.1或者0.0.0.0），保证能够互相连接</li><li>分别修改dir工作目录为当前配置文件目录下(防止出现开启redis服务报can’t not chdir的错误)</li><li>打开aof日志文件功能</li><li>开启cluster集群模式**# cluster-enabled yes**(去掉注释#即可) </li><li>集群配置文件同样以”cluster-config-file nodes-xxxx.conf”格式生成(端口号区分)</li><li>节点超时时间统一设置为5000ms(可选)</li></ol><h3 id="开启集群"><a href="#开启集群" class="headerlink" title="开启集群"></a>开启集群</h3><ul><li>先把配置好的6个节点开启</li></ul><p><strong>注意：网上的方法大都是用ruby脚本来搭建集群，但在Redis for windows 5.0 这版本里，不再使用ruby脚本搭建！而是直接用redis-cli来搭建！</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">redis-cli --cluster create  <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6379 127.0</span>.<span class="hljs-number">0.1:6380</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6381 127.0</span>.<span class="hljs-number">0.1:6382</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">6383 127.0</span>.<span class="hljs-number">0.1:6384</span> --cluster-replicas <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>create选项后跟着的是已经开启的节点的IP:PORT号</strong><br>–cluster-replicas选项后面跟着的是每个节点所拥有的从节点数<br><br>这里配置的值是1，则6个节点里有3个主节点，3个从节点<br><br>所以在开启时，自动将输入的前3个节点(按先后顺序)配置为主节点，后面三个配置为从节点(按主节点的先后顺序)<br></p><p>输入命令后，按提示输入yes，等待集群创建好即可</p><h3 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-cli -c -p 主节点端口号 <span class="hljs-regexp">//</span>-c表示进入集群模式，不开启则不会出现节点的跳转！集群也不能使用！<br></code></pre></td></tr></table></figure><p><strong>即使连接了从节点，进行数据的读写时，也会发生节点的跳转</strong><br><br><br>其余关于主节点和从节点的增删改,cmd中输入</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis-<span class="hljs-keyword">cli</span> --<span class="hljs-keyword">cluster</span> <span class="hljs-keyword">help</span> <br></code></pre></td></tr></table></figure><p>查看文档及其相关操作即可</p><h3 id="集群使用注意"><a href="#集群使用注意" class="headerlink" title="集群使用注意"></a>集群使用注意</h3><ol><li>只有主节点才有HashSlot，从节点没有，从节点只负责数据的同步</li><li>主节点不可直接删除(主节点一删除，HashSlot不完整，集群也就不可使用)，从节点能直接删除</li><li>增加新的主节点时，要分配Slot才能用，删除时要先移除拥有的slot才能删除</li><li>修改从节点的所属主节点要连接这个从节点才能修改</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于Redis的基础部分学习都学完了，👴终于学废了，不说了，继续学</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化</title>
    <link href="/2021/02/14/redis%E6%8C%81%E4%B9%85%E5%8C%96/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2021/02/14/redis%E6%8C%81%E4%B9%85%E5%8C%96/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将数据从内存储存到硬盘的过程叫做数据的持久化，这次👴将要学习两种Redis将数据持久化的方法</p><h2 id="快照-Snapshot"><a href="#快照-Snapshot" class="headerlink" title="快照(Snapshot)"></a>快照(Snapshot)</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>将某一时刻的所有数据写入硬盘中</strong>，是redis默认开启的持久化方式，以.rdb的文件保存，也叫RDB方法</p><blockquote><p>Windows环境下dump.rdb保存在安装目录中</p></blockquote><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><ol><li>客户端用bgsave和save的方法来生成快照</li></ol><p><strong>bgsave和save的区别</strong><br></p><ul><li>客户端接受到bgsave指令时，会fork一个子进程负责生成快照，父进程则继续处理执行命令，最大的好处就是不会阻塞服务端，并保证快照的生成</li><li>客户端接受到save指令时，redis的服务器在快照生成完之前，不会相应其他的命令.处于阻塞状态.（主进程负责快照生成）</li></ul><ol start="2"><li>服务器配置自动触发</li></ol><p><strong>在redis.windows.config中进行配置</strong>，如果满足save中的任意一个条件，都会进行快照的生成<br><img src="/img/redis-learning/%E6%8C%81%E4%B9%85%E5%8C%96/1.PNG"><br>3. 服务端接受shutdown指令<br><strong>当服务端接受到shutdown指令时，会执行save指令，阻塞所有客户端，不再执行任何命令。在save执行完后，再关闭服务器</strong></p><h3 id="存在缺陷"><a href="#存在缺陷" class="headerlink" title="存在缺陷"></a>存在缺陷</h3><p><strong>完成一次快照的生成后，到下一次快照的生成之前，这段时间的数据是没有保障的！也就是说，这段时间的数据容易丢失！</strong></p><h2 id="追加日志文件-AOF"><a href="#追加日志文件-AOF" class="headerlink" title="追加日志文件(AOF)"></a>追加日志文件(AOF)</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>将所有客户端执行的命令记录到日志文件中，AOF持久化被执行的命令写入到AOF日志文件的末尾，以此来记录数据发生的变化。只要Redis完整执行一遍aof文件包含的命令，就能恢复aof文件记录的数据集</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><strong>Redis默认没有开启AOF日志文件</strong>，所以要去redis.windows.conf中开启，搜索append only file,将no改为yes,保存并重启redis后就能使用AOF功能。<br><strong>保存的日志文件默认为appendonlyfile.aof</strong></p><h3 id="追加频率"><a href="#追加频率" class="headerlink" title="追加频率"></a>追加频率</h3><ol><li>always (慎用)</li></ol><p><strong>只要有写命令提交，马上就同步到磁盘中， 这种方法虽然能够保证数据的完整与安全，但这种同步策略会导致要对磁盘进行巨量的写入操作，从而导致redis处理命令的速度受限于磁盘的性能</strong><br>更为重要的是,这种模式对于SSD硬盘来讲，会大大降低其寿命（写入放大问题：<strong>不断</strong>向磁盘中写入少量数据(即小文件)会损耗磁盘）</p><ol start="2"><li>everysec(推荐)</li></ol><p><strong>每秒执行一次同步，显式的将多个写命令同步到磁盘中</strong><br><br>该同步策略能够兼顾数据安全和性能，redis每秒同步一次aof文件的性能和不使用任何持久化特性的性能比，没有任何差距，即使系统崩溃，redis也最多丢失一秒内的数据。</p><ol start="3"><li>no(不推荐)</li></ol><p><strong>该策略由系统决定何时进行同步</strong><br><br>对性能没有任何影响，但系统一旦崩溃，会丢失一定数量的数据(大意是如果系统决定同步前，系统宕机了，那么同步前的数据就会全部GG)，而且如果硬盘处理写入速度不够快，当缓冲区被等待被写入的数据填满时，redis会进入阻塞态，从而导致redis处理命令的速度变慢(大意是当系统决定开始同步后，如果数据累积到一定程度，大量的数据写入硬盘时，就又会让redis受限于硬盘的性能)。</p><h3 id="修改频率"><a href="#修改频率" class="headerlink" title="修改频率"></a>修改频率</h3><p><strong>Redis默认同步策略为everysec</strong><br><br>一般来说不用修改，但如果有需求，要去配置文件中，查找appendsync，修改对应频率即可.</p><h3 id="存在缺陷-1"><a href="#存在缺陷-1" class="headerlink" title="存在缺陷"></a>存在缺陷</h3><p>虽然能够保证数据的完整性，但不断的同步也会让持久化文件变得越来越大，数据也会变得冗余，例如，<strong>我们调用100次incr test命令，根据AOF持久化机制，这100条命令会被写入AOF日志中</strong>，实际上，有99条命令是多余的，因为要恢复数据库的状态，只需日志中保存一条set test 100足矣。因此为了<strong>压缩AOF文件</strong>，Redis提供了AOF重写机制。</p><h2 id="AOF日志文件重写"><a href="#AOF日志文件重写" class="headerlink" title="AOF日志文件重写"></a>AOF日志文件重写</h2><p><strong>用于解决AOF日志文件过大的问题</strong></p><h3 id="触发重写的方法"><a href="#触发重写的方法" class="headerlink" title="触发重写的方法"></a>触发重写的方法</h3><ol><li>客户端触发重写<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">BGREWRITEAOF <span class="hljs-regexp">//</span>不会阻塞客户端<br></code></pre></td></tr></table></figure></li><li>服务器配置自动触发<br><br>在配置文件中搜索auto-aof-rewrite-percentage后，即可配置，当启用了aof重写机制时，如果aof文件超过min-size(默认64mb),且比上次的aof文件重写后，大了percentage倍后(默认100%)，就会触发自动重写，如果重写很频繁，可以将percentage改大<br>(AOF文件越小，重写也越频繁，当AOF文件非常大时，重写会消耗大量系统资源，所以要将percentage改大,避免频繁重写)</li></ol><h3 id="重写的原理"><a href="#重写的原理" class="headerlink" title="重写的原理"></a>重写的原理</h3><p><strong>重写并没有读取旧AOF文件</strong>而是将整个内存中的数据库内容以命令的方式，重写了一个新的AOF文件，并替换原AOF文件（与快照有点类似）<br><br></p><blockquote><p>说白了就是文件的替换</p></blockquote><h4 id="重写的大致流程"><a href="#重写的大致流程" class="headerlink" title="重写的大致流程"></a>重写的大致流程</h4><ul><li>redis先fork一个子进程,子进程会根据当前内存中的数据快照，往临时文件中写入重建数据库状态的命令</li><li>父进程继续处理后续的命令，一方面继续把命令追加写入旧的AOF文件中，另一方面则把收到的新命令缓存起来。(目的是为了保证如果子进程重写失败，不会出现数据丢失等问题)</li><li>子进程完成写入后，发信号通知父进程，父进程则会开始把缓存的新命令写入这个临时文件中</li><li>父进程完成写入后，可以用这个临时文件替换掉旧的AOF文件，后续的命令也会在这个新的AOF文件中进行追加</li></ul><h2 id="持久化总结"><a href="#持久化总结" class="headerlink" title="持久化总结"></a>持久化总结</h2><p>两种持久化方法能同时使用，也能单独使用，甚至不使用，具体使用取决于数据和应用决定<br><strong>无论用哪种，将数据持久化到硬盘中是十分有必要的</strong></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好家伙，学到这👴用了快四天的时间，👴果然是个垃圾,这就继续学，不BB了</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五种值类型的操作</title>
    <link href="/2021/02/12/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/02/12/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/%E4%BA%94%E7%A7%8DValue%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在对redis有个基本的了解以后，相关的键值操作也是少不了的，上篇文章就学习了相关的key操作，而这次👴就开始学习与value有关的操作</p><h1 id="String类型的操作"><a href="#String类型的操作" class="headerlink" title="String类型的操作"></a>String类型的操作</h1><h2 id="String的内存储存"><a href="#String的内存储存" class="headerlink" title="String的内存储存"></a>String的内存储存</h2><p><img src="/img/redis-learning/String/redis0.PNG" alt="储存模型"><br>key,value都是String类</p><h2 id="设置key-value"><a href="#设置key-value" class="headerlink" title="设置key-value"></a>设置key-value</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> key <span class="hljs-comment">value</span> <br></code></pre></td></tr></table></figure><h2 id="获取key-value"><a href="#获取key-value" class="headerlink" title="获取key-value"></a>获取key-value</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="设置-获取多个key-value"><a href="#设置-获取多个key-value" class="headerlink" title="设置/获取多个key-value"></a>设置/获取多个key-value</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">mset</span></span> key value key value key value...<br><span class="hljs-function"><span class="hljs-title">mget</span></span> key1 key2 key3...<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis14.PNG" alt="mget&amp;mset"></p><hr><h2 id="获取并设置新值"><a href="#获取并设置新值" class="headerlink" title="获取并设置新值"></a>获取并设置新值</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">getset key value</span><br></code></pre></td></tr></table></figure><blockquote><p>设置成功会返回原值(如果新值跟旧值相同，也会操作成功)<br><img src="/img/redis-learning/String/redis15.PNG" alt="getset"></p></blockquote><hr><h2 id="获取对应key的value长度"><a href="#获取对应key的value长度" class="headerlink" title="获取对应key的value长度"></a>获取对应key的value长度</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">strlen</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis16.PNG" alt="strlen"></p><hr><h2 id="追加对应key的value内容"><a href="#追加对应key的value内容" class="headerlink" title="追加对应key的value内容"></a>追加对应key的value内容</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">append</span> <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis17.PNG" alt="append"><br><strong>返回的是追加内容后value的长度</strong></p><hr><h2 id="截取value内容"><a href="#截取value内容" class="headerlink" title="截取value内容"></a>截取value内容</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">getrange<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> //<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>表示索引,从<span class="hljs-number">0</span>开始<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis18.PNG" alt="getrange"></p><hr><h2 id="设置key-value并指定存活时间"><a href="#设置key-value并指定存活时间" class="headerlink" title="设置key-value并指定存活时间"></a>设置key-value并指定存活时间</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">setex key seconds value <span class="hljs-regexp">//</span>秒<br>psetex key milliseconds value <span class="hljs-regexp">//</span>毫秒<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis19.PNG" alt="setex&amp;psetex"></p><hr><h2 id="Setnx"><a href="#Setnx" class="headerlink" title="Setnx"></a>Setnx</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">setnx key value</span><br></code></pre></td></tr></table></figure><blockquote><p>如果key存在，返回0，并不做任何操作（不覆盖），如果不存在，返回1，设置key-value</p></blockquote><p><img src="/img/redis-learning/String/redis20.PNG" alt="setnx"></p><hr><h2 id="原子操作msetnx"><a href="#原子操作msetnx" class="headerlink" title="原子操作msetnx"></a>原子操作msetnx</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">msetnx <span class="hljs-built_in">key</span> value <span class="hljs-built_in">key</span> value <span class="hljs-built_in">key</span> value....<br></code></pre></td></tr></table></figure><p><strong>只要有一个key存在，则不做任何添加操作！</strong><br><img src="/img/redis-learning/String/redis21.PNG" alt="msetnx"></p><hr><h2 id="减操作"><a href="#减操作" class="headerlink" title="减操作"></a>减操作</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">decr <span class="hljs-built_in">key</span><br>decrby <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><strong>只有key对应的value是整型时，操作才会成功！否则会报错</strong><br><img src="/img/redis-learning/String/redis22.PNG" alt="decr"></p><hr><p><img src="/img/redis-learning/String/redis23.PNG" alt="decrby"></p><hr><h2 id="加操作"><a href="#加操作" class="headerlink" title="加操作"></a>加操作</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">incr <span class="hljs-built_in">key</span><br>incrby <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><p><strong>同减操作!</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">incrbyfloat key value<span class="hljs-regexp">//</span>浮点数的加操作<br></code></pre></td></tr></table></figure><blockquote><p>精度保留17位,<strong><em>进1法</em></strong>舍去17位之后的数<br><img src="/img/redis-learning/String/redis24.PNG" alt="incrbyfloat"></p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><h1 id="List类型的操作"><a href="#List类型的操作" class="headerlink" title="List类型的操作"></a>List类型的操作</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p><img src="/img/redis-learning/List/1.PNG" alt="内存模型"><br><strong>相当于java中的list集合,元素有序,且可以重复</strong><br>Redis中List是个堆栈，也遵循FILO（先进后出）的原则.</p><h2 id="创建、遍历列表"><a href="#创建、遍历列表" class="headerlink" title="创建、遍历列表"></a>创建、遍历列表</h2><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">lpush <span class="hljs-built_in">key</span> [value...] //从左<span class="hljs-built_in">push</span><br>lpushx <span class="hljs-built_in">key</span> [value...] //从左<span class="hljs-built_in">push</span>,且<span class="hljs-built_in">key</span>是已经存在的<br>rpush <span class="hljs-built_in">key</span> [value...] //从右<span class="hljs-built_in">push</span><br>rpushx <span class="hljs-built_in">key</span> [value...] //从右<span class="hljs-built_in">push</span>,且<span class="hljs-built_in">key</span>是已经存在的<br></code></pre></td></tr></table></figure><p><strong>lpush最后入栈的元素就是栈首<br>rpush最后入栈的元素就是栈尾</strong></p><ul><li>push成功后返回堆栈长度</li><li>pushx如果key不存在，不会报错，返回0表示key对应的堆栈不存在，如果存在，返回push后的堆栈长度</li><li>pushx不能创建列表<h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lrange</span> key start end //遍历某一区间的列表(从栈首遍历)<br></code></pre></td></tr></table></figure><img src="/img/redis-learning/List/2.PNG" alt="push&amp;range"></li></ul><hr><h2 id="移除列表元素"><a href="#移除列表元素" class="headerlink" title="移除列表元素"></a>移除列表元素</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">lpop key <span class="hljs-regexp">//</span>移除并返回栈首的元素<br>rpop key <span class="hljs-regexp">//</span>移除并返回栈尾的元素<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/List/3.PNG" alt="pop"></p><hr><h2 id="获取列表长度"><a href="#获取列表长度" class="headerlink" title="获取列表长度"></a>获取列表长度</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">llen key</span><br></code></pre></td></tr></table></figure><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lset</span> key index newvalue<br></code></pre></td></tr></table></figure><blockquote><p>修改的是key对应列表中索引为index的值,即 <strong>list[index]</strong> 的值</p></blockquote><p><img src="/img/redis-learning/List/4.PNG" alt="set"></p><hr><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lindex</span> key index<br></code></pre></td></tr></table></figure><p><strong>获取list[index]的元素</strong><br><img src="/img/redis-learning/List/5.PNG" alt="set"></p><hr><h2 id="删除重复元素"><a href="#删除重复元素" class="headerlink" title="删除重复元素"></a>删除重复元素</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">lrem <span class="hljs-built_in">key</span> <span class="hljs-built_in">count</span> <span class="hljs-built_in">value</span><br></code></pre></td></tr></table></figure><p><strong>从左遍历列表，删除count个重复的元素value</strong></p><ul><li>如果value不存在，则不会报错，只是返回0</li><li>如果value存在，返回的是删除的value个数</li></ul><p><img src="/img/redis-learning/List/6.PNG" alt="rem"></p><hr><h2 id="截取列表"><a href="#截取列表" class="headerlink" title="截取列表"></a>截取列表</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">ltrim<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>截取list中start到end的部分</strong></p><ul><li>截取后key对应的列表<strong>被替换成原先列表中截取的部分</strong>，且截取部分的元素<strong>索引也会从0开始从新编号</strong></li><li>如果截取部分的索引 <strong>不在list的范围内(超出范围)</strong> 那么截取操作的结果也是OK的！！！  <strong>不会报错</strong> ，但截取后key的列表为空(截取部分为空，所以列表也为空)</li></ul><p><img src="/img/redis-learning/List/7.PNG" alt="trim"></p><hr><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">linsert</span> key before value //在<span class="hljs-keyword">list</span>中的before元素前插入value<br><span class="hljs-keyword">linsert</span> key <span class="hljs-keyword">after</span> value //在<span class="hljs-keyword">list</span>中的<span class="hljs-keyword">after</span>元素后插入value<br></code></pre></td></tr></table></figure><ul><li><strong>如果list中存在重复的before(after)元素，则会选取从左遍历的第一个出现的before(after)元素</strong></li><li>返回插入元素后列表的长度</li></ul><p><img src="/img/redis-learning/List/8.PNG" alt="insert"></p><hr><h1 id="Set类型的操作"><a href="#Set类型的操作" class="headerlink" title="Set类型的操作"></a>Set类型的操作</h1><h2 id="内存模型-1"><a href="#内存模型-1" class="headerlink" title="内存模型"></a>内存模型</h2><p><img src="/img/redis-learning/Set/1.PNG" alt="内存模型"><br><strong>特点：是一个元素无序，且元素不可重复的集合</strong></p><h2 id="集合的创建与遍历"><a href="#集合的创建与遍历" class="headerlink" title="集合的创建与遍历"></a>集合的创建与遍历</h2><h3 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sadd</span> key value or<span class="hljs-meta"> [value...]</span><br></code></pre></td></tr></table></figure><ul><li><strong>创建时，如果value中有重复的，也能成功创建，重复的value会自动的忽略</strong></li><li>创建后返回集合的大小</li></ul><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">smembers key</span><br></code></pre></td></tr></table></figure><p><strong>注意！这里输出是有序的是因为Redis会自动比较值大小再输出！并不改变集合本身！这个集合的底层仍是无序的！这与集合的特点不矛盾！</strong><br><img src="/img/redis-learning/Set/2.PNG" alt="sadd&amp;smembers"></p><h2 id="查看集合的大小"><a href="#查看集合的大小" class="headerlink" title="查看集合的大小"></a>查看集合的大小</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scard key</span><br></code></pre></td></tr></table></figure><ul><li>返回集合大小</li></ul><h2 id="元素的删除"><a href="#元素的删除" class="headerlink" title="元素的删除"></a>元素的删除</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">spop <span class="hljs-built_in">key</span> <span class="hljs-built_in">count</span> <span class="hljs-comment">//随机删除</span><br>srem <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span> <span class="hljs-built_in">or</span> [<span class="hljs-built_in">value</span>....] <span class="hljs-comment">//删除一个或多个指定元素</span><br></code></pre></td></tr></table></figure><ul><li>在集合中spop随机选取count个元素删除，并返回删除的元素,srem则是删除指定的元素</li><li>spop如果删除的个数超过集合的大小，则默认将集合的所有元素删除</li><li>srem如果删除的元素不存在，则不会执行删除操作，返回0<br><img src="/img/redis-learning/Set/3.PNG" alt="pop"></li></ul><hr><p><img src="/img/redis-learning/Set/4.PNG" alt="pop"></p><hr><p><img src="/img/redis-learning/Set/6.PNG" alt="rem"></p><hr><h2 id="元素的移动"><a href="#元素的移动" class="headerlink" title="元素的移动"></a>元素的移动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">smove <span class="hljs-built_in">source</span> destination member<br></code></pre></td></tr></table></figure><ul><li>只能用于集合之间的元素移动</li><li>移动不存在的member不会报错，返回0(不发生移动)</li><li>移动后，返回移动元素的个数（一次移一个）</li></ul><p><img src="/img/redis-learning/Set/5.PNG" alt="smove"></p><hr><h2 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sismember <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure><h2 id="随机返回元素"><a href="#随机返回元素" class="headerlink" title="随机返回元素"></a>随机返回元素</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">srandmember </span>key <span class="hljs-built_in">count</span><br></code></pre></td></tr></table></figure><ul><li>随机返回集合中的count个元素</li></ul><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sdiff akey <span class="hljs-keyword">bkey </span><span class="hljs-keyword">or </span>[<span class="hljs-keyword">bkey...]</span><br></code></pre></td></tr></table></figure><ul><li>求出akey和bkey的减集(去除akey集合中其他bkey集合中<strong>相同的</strong>元素)</li><li>这个操作不会删除集合的元素，只是计算！</li></ul><h2 id="求交集"><a href="#求交集" class="headerlink" title="求交集"></a>求交集</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sinter akey bkey</span><br></code></pre></td></tr></table></figure><h2 id="求并集"><a href="#求并集" class="headerlink" title="求并集"></a>求并集</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sunion akey bkey</span><br></code></pre></td></tr></table></figure><hr><h1 id="ZSet类型的操作"><a href="#ZSet类型的操作" class="headerlink" title="ZSet类型的操作"></a>ZSet类型的操作</h1><h2 id="内存模型-2"><a href="#内存模型-2" class="headerlink" title="内存模型"></a>内存模型</h2><p>特点: 可排序，不重复的set集合 (sortSet) 靠分数排序,不靠元素排序<br><strong>其本质仍然是set，set本身不可排序，靠分数才会让set有序</strong><br><img src="/img/redis-learning/ZSet/1.PNG"></p><hr><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">zadd</span> key<span class="hljs-meta"> [score value ... ]</span><br></code></pre></td></tr></table></figure><ul><li>如果创建了重复的key，则最后创建的会覆盖最先创建的</li><li>创建成功后，返回zset大小</li><li>创建成功后，会自动根据分数进行排序<h2 id="查看大小"><a href="#查看大小" class="headerlink" title="查看大小"></a>查看大小</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">zcard key</span><br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">zrange<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> [withscores] //遍历某一范围内的元素，可选是否显示分数<br>zrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span> [withscores] [limit <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>] //遍历某一分数范围内的元素，可选是否选择分数，是否展示<span class="hljs-keyword">start</span>到<span class="hljs-keyword">end</span>的查找结果<br></code></pre></td></tr></table></figure><h2 id="查看排名"><a href="#查看排名" class="headerlink" title="查看排名"></a>查看排名</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> //查看集合中<span class="hljs-built_in">member</span>的排名<br>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> //查看集合中<span class="hljs-built_in">member</span>的倒序排名<br></code></pre></td></tr></table></figure></li><li>排名从0开始排</li><li>排名根据分数来排，并非元素本身！</li></ul><h2 id="查看元素分数"><a href="#查看元素分数" class="headerlink" title="查看元素分数"></a>查看元素分数</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> //查看集合中<span class="hljs-built_in">member</span>的分数<br></code></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zrem <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> <span class="hljs-keyword">or</span> [<span class="hljs-built_in">member</span>...] //移除一个或多个<span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure><ul><li>移除不存在的元素只会返回0</li></ul><h2 id="加分"><a href="#加分" class="headerlink" title="加分"></a>加分</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span> // 给特定的<span class="hljs-built_in">member</span>增加increment分<br></code></pre></td></tr></table></figure><ul><li>这个increment分可以带小数</li><li>返回值是增加后member的分数</li></ul><h1 id="Hash类型的操作"><a href="#Hash类型的操作" class="headerlink" title="Hash类型的操作"></a>Hash类型的操作</h1><h2 id="内存模型-3"><a href="#内存模型-3" class="headerlink" title="内存模型"></a>内存模型</h2><p>特点: key对应的value还是key-value型的值，Map&lt;key,Map&lt;key,value&gt;&gt; map（套娃）,这个套娃的map结构的key无序</p><p>!()[/img/redis-learning/ZSet/2.png]</p><h2 id="创建添加"><a href="#创建添加" class="headerlink" title="创建添加"></a>创建添加</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hset</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value...] <br><span class="hljs-symbol">hsetnx</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value...] <span class="hljs-comment">//最大的区别是如果字段存在，则不会进行覆盖操作，如果不存在，则进行添加操作</span><br></code></pre></td></tr></table></figure><ul><li>创建成功后返回field-value的个数</li><li>如果创建的key有重复，则不会覆盖，如果创建的field有重复，则最后创建的会覆盖最新创建的</li></ul><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">hget key field <span class="hljs-regexp">//</span>获取key中字段名为field的value<br>hgetall key <span class="hljs-regexp">//</span>获取key的所有字段和value<br></code></pre></td></tr></table></figure><h2 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">hdel <span class="hljs-built_in">key</span> field <span class="hljs-keyword">or</span> [field...] //删除<span class="hljs-built_in">key</span>中的一个或多个字段<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">or</span> [<span class="hljs-built_in">key</span>...] //删除整个<span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="判断key"><a href="#判断key" class="headerlink" title="判断key"></a>判断key</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">hexists<span class="hljs-built_in"> key</span> field //判<span class="hljs-built_in">断key</span>中的field字段是否存在<br>exists<span class="hljs-built_in"> key</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">[key</span>...] //判<span class="hljs-built_in">断key</span>存不存在<br></code></pre></td></tr></table></figure><h2 id="获取所有key"><a href="#获取所有key" class="headerlink" title="获取所有key"></a>获取所有key</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hkeys key <span class="hljs-regexp">//</span>获取key的所有字段名<br></code></pre></td></tr></table></figure><h2 id="获取所有vals"><a href="#获取所有vals" class="headerlink" title="获取所有vals"></a>获取所有vals</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hvals key <span class="hljs-regexp">//</span>获取key中所有的value<br></code></pre></td></tr></table></figure><p><strong>hgetall就是hkeys+hvals的整合，注意区别</strong></p><h2 id="设置多个field-value"><a href="#设置多个field-value" class="headerlink" title="设置多个field-value"></a>设置多个field-value</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hmset</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value...]<br></code></pre></td></tr></table></figure><p><strong>hset现在也能一次放多个field value</strong></p><h2 id="获取多个key-value"><a href="#获取多个key-value" class="headerlink" title="获取多个key-value"></a>获取多个key-value</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hmget</span> key <span class="hljs-meta">field</span> value or [<span class="hljs-meta">field</span> value ...]<br></code></pre></td></tr></table></figure><h2 id="加操作-1"><a href="#加操作-1" class="headerlink" title="加操作"></a>加操作</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hincrby</span> key <span class="hljs-meta">field</span> increment <span class="hljs-comment">//为字段增加整数数值</span><br><span class="hljs-symbol">hincrbyfloat</span> key <span class="hljs-meta">field</span> increment <span class="hljs-comment">//为字段增加浮点数数值</span><br></code></pre></td></tr></table></figure><ul><li>如果这个字段的value不是整型或浮点型，操作会失败</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>学个命令也学了两天，看来👴是真的拉跨，但还是要学啊，学着先吧</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始Redis</title>
    <link href="/2021/02/10/%E5%88%9D%E5%A7%8BRedis/%E5%88%9D%E5%A7%8BRedis/"/>
    <url>/2021/02/10/%E5%88%9D%E5%A7%8BRedis/%E5%88%9D%E5%A7%8BRedis/</url>
    
    <content type="html"><![CDATA[<h1 id="初学Redis"><a href="#初学Redis" class="headerlink" title="初学Redis"></a>初学Redis</h1><blockquote><p>在每学习一门新技术前，了解它是用于解决什么问题的？怎么解决的？应用场景是啥？与别的技术比，又有啥优势？往往能够对这个技术有个非常好的自我认知与定位</p></blockquote><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>基于<strong>内存</strong>进行储存，操作的是内存中的数据</li><li>支持<strong>key-value</strong>的储存形式</li><li>底层是用<strong>C语言</strong>编写的</li><li>NoSQL类数据库(Not only SQL) 非关系型数据库</li><li>Redis的操作都是<strong>原子性</strong>的，要么都执行成功，要么都执行失败</li><li>支持数据持久化机制(也是Redis称为数据库的重要原因)</li><li>是单进程，单线程的设计（不支持并发，不存在线程安全问题） –&gt; 设计分布式锁</li></ul><blockquote><p>所以可知Redis的运行处理效率非常高,而且没有数据表的概念,直接用key-value的形式完成对数据的管理</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>数据模型比较简单</li><li>对数据库性能要求较高</li><li>不需要高度的数据一致性（NoSQL对事务支持不是很好）</li><li>…等等</li></ul><h2 id="支持的5种数据类型"><a href="#支持的5种数据类型" class="headerlink" title="支持的5种数据类型"></a>支持的5种数据类型</h2><ul><li>String 字符串</li><li>List 列表</li><li>Set 无序集合</li><li>ZSet 有序集合</li><li>Hash 哈希</li></ul><blockquote><p>哈希的结构在Redis中很特殊，其结构为<br><strong>Key : { Key : value }</strong></p></blockquote><h2 id="Redis的安装与使用-Windows环境"><a href="#Redis的安装与使用-Windows环境" class="headerlink" title="Redis的安装与使用(Windows环境)"></a>Redis的安装与使用(Windows环境)</h2><p>Redis的安装是我们接触Redis时出现的第一个难题</p><p><strong>注意</strong><br></p><blockquote><p>Redis官方是没有windows环境下的安装包的!也就是说，要想使用原生的Redis，只能在Linux环境下使用!<br><strong>(微软其实做过Windows下的Redis环境，但GitHub上的代码很久没更新，说明可能弃坑了！)</strong>.</p></blockquote><p><br>那么，使用windows的用户是不是用不了呢？并不是！<br><br><strong>以下有三种方法能够在Windows下使用Redis！</strong></p><ol><li>通过<strong>虚拟机</strong>来使用Redis</li><li>通过安装<strong>WSL</strong>来使用Redis </li><li>通过安装Github上其他大神的Redis包，来使用redis<br>链接如下:<a href="https://github.com/tporadowski/redis/releases">Redis Install</a></li></ol><p>上面三种方法怎么选呢？我的意见如下:</p><ul><li>第一种:简单粗暴，但并不推荐，虚拟机占用资源十分大！如果两平台操作，难免会卡顿，影响操作体验,不介意者推荐使用！<br></li><li>第二种:WSL意思是Windows的子系统，这个子系统能够安装Linux的分发版，不同的是没有图形界面操作，只有命令行操作，所以占用空间小，但是安装过程以及配置操作较繁杂,没有耐心整的话也不推荐<br></li><li>第三种: 安装过程简单粗暴，使用也不复杂，缺点就是不是原生的，没有官方的技术支持，未知的bug和版本的小落后等，但对于正在学习的我们来说够用了<br></li></ul><blockquote><p><strong>注意</strong> 第三种方法的安装只支持64位系统！</p></blockquote><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤:"></a>安装步骤:</h3><blockquote><p>对于我来讲，第三种方法是最简便的<del>(老懒狗了)</del>，所以就简单的记录下，第三种的安装步骤</p></blockquote><ol><li>打开链接，选择msi安装包(原因看下面！)</li><li>下载好后，创建一个文件夹来存放redis，推荐放系统盘以外的盘</li><li>以管理员身份运行安装包(安装过程如果出现错误代码2502，2503，多半是权限不足),具体怎么以管理员身份运行，可以自行百度”以管理员身份运行msi文件”,</li><li>跟着提示走，Next，选定Redis存放位置(放在第二步创建的文件里),ADD PATH(省去自己配置环境变量的步骤，所以选msi文件安装，<del>我猜的</del>),整完这些后，提示安装成功就能退出安装程序了.</li></ol><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h3><ol><li>输入<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">redis-server</span> <span class="hljs-selector-tag">--service-install</span> <span class="hljs-selector-tag">redis</span><span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.conf</span><br></code></pre></td></tr></table></figure>部署Redis在windows下的服务(关闭cmd后redis服务就会自动关闭)</li><li>(配置好环境变量后)启动cmd命令行,输入<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span>.exe<br></code></pre></td></tr></table></figure>启动redis服务，命令台会出现相应的信息<img src="/img/redis-learning/String/redis1.PNG" alt="开启服务"></li><li>新开一个cmd<br>(第2步的cmd别关，否则无法访问redis服务端！)，输入<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">redis-<span class="hljs-keyword">cli</span>.exe <br></code></pre></td></tr></table></figure>开始访问redis(默认端口为6379)</li><li>输入ping，查看输出,输入 set a 111 存储键值对，输入get a取出键值对，查看输出结果</li><li>以上如果都能正常输出，那么就能正常使用redis <img src="/img/redis-learning/String/redis2.PNG" alt="输入和输出"></li></ol><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令:"></a>常用指令:</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-server --service-stop <span class="hljs-regexp">//</span>停止服务<br>redis-server --service-start <span class="hljs-regexp">//</span>开启服务<br>redis-server --service-uninstall <span class="hljs-regexp">//</span>卸载服务<br>redis-cli -p 端口号 --raw <span class="hljs-regexp">//</span>指定端口号启动，并让转化中文编码，显示中文<br></code></pre></td></tr></table></figure><h3 id="修改Redis配置"><a href="#修改Redis配置" class="headerlink" title="修改Redis配置"></a>修改Redis配置</h3><ul><li><p>启动端口修改: 安装目录下找到redis.windows-service.conf,打开后，搜索port,直接修改即可</p><blockquote><p>修改完后不能直接重新启动Redis!否则配置不会生效！应用命令<br></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">redis-server</span> <span class="hljs-selector-tag">redis</span><span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.conf</span><br></code></pre></td></tr></table></figure><p>使<strong>全部修改的配置</strong>生效！</p></li><li><p>database库</p><blockquote><p>存放数据的一个基本单元，每个库都能存放key-value键值对，redis中每个库都有独有的id，从0开始，redis默认有16个库(0-15号)，默认为0号库，每个库之间数据是独立的！</p></blockquote></li></ul><p><strong>库的数目也能修改，在redis.windows.conf中搜索databases 更改数字即可！</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">select 库id <span class="hljs-regexp">//</span>选择某个库<br>flushDB <span class="hljs-regexp">//</span>清空当前库的数据<br>flushAll <span class="hljs-regexp">//</span>清空全部库的数据<br></code></pre></td></tr></table></figure><p><img src="/img/redis-learning/String/redis3.PNG" alt="FLUSHDB"></p><hr><p><img src="/img/redis-learning/String/redis4.PNG" alt="FLUSHALL"></p><hr><h2 id="操作KEY的指令"><a href="#操作KEY的指令" class="headerlink" title="操作KEY的指令"></a>操作KEY的指令</h2><h3 id="删除key"><a href="#删除key" class="headerlink" title="删除key"></a>删除key</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">del</span> [<span class="hljs-built_in">key</span>...]<br></code></pre></td></tr></table></figure><ul><li>删除一个或多个key，不存在的会被忽略</li><li>返回删除key的数量<br><img src="/img/redis-learning/String/redis5.PNG" alt="del key"></li></ul><hr><h3 id="检查key存在与否"><a href="#检查key存在与否" class="headerlink" title="检查key存在与否"></a>检查key存在与否</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">exists</span> key<br></code></pre></td></tr></table></figure><ul><li>若key存在返回1，反之返回0<br><img src="/img/redis-learning/String/redis6.PNG" alt="exists key"></li></ul><hr><h3 id="设置key存活时间"><a href="#设置key存活时间" class="headerlink" title="设置key存活时间"></a>设置key存活时间</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">expire key seconds <span class="hljs-regexp">//</span>以秒为单位<br>pexpire key millsseconds <span class="hljs-regexp">//</span>以毫秒为单位<br>pexpireat key milliseconds <span class="hljs-regexp">//</span>以毫秒为单位的unix时间戳<br></code></pre></td></tr></table></figure><ul><li>设置key存活时间(秒)，一旦过期，key就会被删除</li><li>设置成功返回1，反之返回0</li><li>时间复杂度O(1)</li></ul><p><img src="/img/redis-learning/String/redis7.PNG" alt="expire key"></p><hr><h3 id="查看key剩余存活时间"><a href="#查看key剩余存活时间" class="headerlink" title="查看key剩余存活时间"></a>查看key剩余存活时间</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ttl key <span class="hljs-regexp">//</span>以秒为单位<br>pttl KEY <span class="hljs-regexp">//</span>以毫秒为单位<br></code></pre></td></tr></table></figure><ul><li>查看对应key的剩余存活时间</li><li>返回-1，key存活时间为永久，返回-2，key不存在，返回&gt;=0，key的剩余存活时间</li></ul><p><img src="/img/redis-learning/String/redis11.PNG" alt="ttl"></p><h3 id="keys匹配"><a href="#keys匹配" class="headerlink" title="keys匹配"></a>keys匹配</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">例子<br>keys * <span class="hljs-regexp">//</span> 匹配所有keys<br>keys h?llo <span class="hljs-regexp">//</span>匹配hello,hallo,hxllo等  ?--&gt;匹配一个字符<br>keys h*llo <span class="hljs-regexp">//</span>匹配hllo和heeeeello等 *--&gt;匹配多个字符<br>keys h[ae]llo <span class="hljs-regexp">//</span>匹配hallo,hello,不匹配hllo,特殊符号用\隔开<br></code></pre></td></tr></table></figure><ul><li>返回符合匹配的key列表<br><img src="/img/redis-learning/String/redis8.PNG" alt="keys"></li></ul><hr><h3 id="key的移动"><a href="#key的移动" class="headerlink" title="key的移动"></a>key的移动</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">move</span> key dbid<br></code></pre></td></tr></table></figure><ul><li>移动成功返回1，反之返回0<br><img src="/img/redis-learning/String/redis9.PNG" alt="移动成功"></li></ul><hr><p><img src="/img/redis-learning/String/redis10.PNG" alt="移动失败"></p><hr><h3 id="randomkey"><a href="#randomkey" class="headerlink" title="randomkey"></a>randomkey</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">randomkey</span><br></code></pre></td></tr></table></figure><ul><li>当数据库不为空，随机返回一个key，为空则返回nil</li></ul><p><img src="/img/redis-learning/String/redis12.PNG" alt="randomkey"></p><hr><h3 id="key的重命名"><a href="#key的重命名" class="headerlink" title="key的重命名"></a>key的重命名</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">rename</span> <span class="hljs-built_in">key</span> newkey<br></code></pre></td></tr></table></figure><ul><li>将key重命名为newkey,如果key和newkey相同，或者key不存在，返回错误，如果newkey存在，则会覆盖旧值(key对应的value会被newkey对应的value覆盖)<br><img src="/img/redis-learning/String/redis13.PNG" alt="rename"></li></ul><hr><h3 id="查看key的值类型"><a href="#查看key的值类型" class="headerlink" title="查看key的值类型"></a>查看key的值类型</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> keyname<br></code></pre></td></tr></table></figure><ul><li>返回对应key的value的类型<blockquote><p>返回值: <br>none(不存在) <br> string(字符串)<br> list(列表)<br> set(集合)<br> zset(有序集合)<br> hash(哈希)<br></p></blockquote></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>上手学就翻车，好家伙，安装redis这一步就整了好久，初学下来就只记得redis的特点和安装步骤，希望👴没事。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Markdown</title>
    <link href="/2021/02/08/%E5%88%9D%E8%AF%86Markdown/%E5%88%9D%E8%AF%86Markdown/"/>
    <url>/2021/02/08/%E5%88%9D%E8%AF%86Markdown/%E5%88%9D%E8%AF%86Markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown的语法"><a href="#Markdown的语法" class="headerlink" title="Markdown的语法"></a>Markdown的语法</h1><blockquote><p>Markdown是一门标记性的语言，也是我用来写博客必须学会的，所以该博文用于记录Markdown的各种语法，并学会使用Markdown.</p></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//代码块语法:</span><br><span class="hljs-string">&#x27; ```Shell:  代码部分 ``` &#x27;</span><br><span class="hljs-comment">//或者直接使用: </span><br><span class="hljs-string">``</span><span class="hljs-string">` 代码部分  `</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure><h3 id="Java的代码块"><a href="#Java的代码块" class="headerlink" title="Java的代码块"></a>Java的代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//用 ``` Java  ``` 即可生成Java样式的代码块，其他语言同理 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello Markdown!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C系的代码块"><a href="#C系的代码块" class="headerlink" title="C系的代码块"></a>C系的代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Hello Markdown!&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell">//Linux下的命令<br>pwd<br>mkdir<br>touch<br>gcc...<br></code></pre></td></tr></table></figure><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote><p>标题用#号来表示标题，其对应了HTML的5个H标题</p></blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># ---&gt; h1 一级标题<br>## ---&gt; h2 二级标题<br>### ---&gt; h3 三级标题<br>#### ---&gt; h4 四级标题<br>##### ---&gt; h5 五级标题<br>###### ---&gt; h6 六级标题<br></code></pre></td></tr></table></figure><h2 id="与字体有关的语法"><a href="#与字体有关的语法" class="headerlink" title="与字体有关的语法"></a>与字体有关的语法</h2><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**内容**</span> 加粗字体,内容跟*号不分离<br></code></pre></td></tr></table></figure><p><strong>Hello Markdown!</strong> </p><h3 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*内容*</span> 倾斜字体<br></code></pre></td></tr></table></figure><p><em>Hello Markdown!</em></p><h3 id="字体高亮"><a href="#字体高亮" class="headerlink" title="字体高亮"></a>字体高亮</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">=<span class="ruby">=内容== 高亮内容</span><br></code></pre></td></tr></table></figure><p>==Hello Markdown!==</p><h3 id="内容删除样式"><a href="#内容删除样式" class="headerlink" title="内容删除样式"></a>内容删除样式</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~内容~~ 显示删除样式<br></code></pre></td></tr></table></figure><p><del>Hello Markdown!</del></p><h2 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> 内容</span> <br><span class="hljs-meta">&gt;</span><span class="bash">&gt; 内容</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; 内容</span><br>输出效果见下面<br></code></pre></td></tr></table></figure><blockquote><p>Hello Markdown!</p><blockquote><p>Hello Markdown!</p><blockquote><p>Hello Markdown!</p></blockquote></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//全屏分割线</span><br><span class="hljs-string">***</span><br><span class="hljs-string">//部分分割线</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><hr><hr><h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//在线图片，本体图片的插入</span><br>!<span class="hljs-selector-attr">[图片名]</span>(图片地址)<br></code></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1229424709,3319526529&fm=26&gp=0.jpg" alt="在线图片样例"></p><blockquote><p>在线图片会涉及到版权，图床的选择等问题！</p></blockquote><hr><p><img src="/img/default.png" alt="本地图片样例"></p><blockquote><p>本地图片的路径是相对路径！且图片存放路径在/public/img下!</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[链接名](地址)<br></code></pre></td></tr></table></figure><p><a href="https://github.com/kolvzaki">My GitHub</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>无序列表<br>- 目录<span class="hljs-number">1</span><br>- 目录<span class="hljs-number">2</span><br>...<br><span class="hljs-regexp">//</span>有序列表<br>序号.名称<br><span class="hljs-number">1</span>.首页<br><span class="hljs-number">2</span>.目录<br><span class="hljs-number">3</span>.... <br></code></pre></td></tr></table></figure><ul><li>目录1</li><li>目录2</li><li>目录3</li></ul><p>1.首页<br>2.分类<br>3.目录</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 标题1 </span>|<span class="hljs-string"> 标题2   </span>|<span class="hljs-string"> 长长的标题3 </span>|<span class="hljs-string"> title 4 </span>|<br>|<span class="hljs-string"> ----- </span>|<span class="hljs-string"> --------- </span>|<span class="hljs-string"> ----------- </span>|<span class="hljs-string"> ------- </span>|<br>|<span class="hljs-string"> 内容1 </span>|<span class="hljs-string"> content 2 </span>|<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<br>|<span class="hljs-string"> 行3  </span>|<span class="hljs-string"> line3     </span>|<span class="hljs-string"> column 3    </span>|<span class="hljs-string">         </span>|<br></code></pre></td></tr></table></figure><blockquote><p>生成表格语法很麻烦，建议上网搜相关的快速生成</p></blockquote><table><thead><tr><th>标题1</th><th>标题2</th><th>长长的标题3</th><th>title 4</th></tr></thead><tbody><tr><td>内容1</td><td>content 2</td><td></td><td></td></tr><tr><td>行3</td><td>line3</td><td>column 3</td><td></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是👴某种意义上的第一篇博文，也是新的开始，整来这东西希望能改一哈👴的懒癌，再懒下去👴要无了，学习的路线都规划好了，希望不会🕊</p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/06/hello-world/"/>
    <url>/2021/02/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
